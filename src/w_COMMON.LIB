	%assign debug 0
	%include '../include/LMACROS.CPY'
	%include '../include/IMACROS.CPY'
	%include '../include/CONSTANTS.INC'
	%line 5 w_COMMON.LIB

;	=================================================
;	GLOBAL ROUTINES/VARIABLES defined in this library
;	=================================================
;	Routines
;	--------
	global _ENVIRONMENT
	global _SYSERROR
	global _DATE
;V2.13
;	global _RUN
	global _RUN_INTERACTIVE
	global _RUN_BATCH
;V2.13
	global _WAIT
	global _RANDOM
	global _VALIDATE_SRC
	global _VALIDATE_DST
	global _ENDPROGRAM
	global  No_Assist
	global _CMPSTR
	global _MOVESTR
	
;	------
;	Fields
;	------
	global WIN_ReturnCode
	global RETURN_CODE
	global LF
	global CHILD_PID
	global err01
	global err02
	global err03
	global err04
	global err05
	global err06
	global err07
	global err08
	global err09
	global err10
	global err11
	global err12
	global ERROR_CODE	
	global StackAssist
	global w_RecordBuffer
	global w_One
	global w_SaveAddress
	global w_Spaces
	global w_Temp
	global w_TopOfBSS
	global w_BottomOfBSS
	global w_SaveRSP
	global savedRegisters
	global SX

;	===============================================
;	EXTERNAL ROUTINES/VARIABLES used by the library
;	===============================================
;	Windows
;	-------
;	extern GetCommandLineA
	extern GetEnvironmentVariableA
	extern SetConsoleTextAttribute
	extern WriteConsoleA
	extern ExitProcess
	extern GetLocalTime
	extern GetLastError
	extern QueryPerformanceCounter
	extern CreatePipe
	extern SetHandleInformation
	extern CreateProcessA
	extern WaitForSingleObject
	extern CloseHandle
	extern ExitProcess

;	-----------------
;	languageONE
;	-----------------
;	Routines
;	--------
	extern _TOALPHA			; NUMBERS
	extern _FROMALPHA		; NUMBERS
	
;	------
;	Fields
;	------
	extern StdOutHandle		; STDIO
	
;=======================================================================
;			DATA SEGMENT
;=======================================================================
;           Initialised - by program
;-----------------------------------------------------------------------
			section .data

;	System error messages. -1 thru -133
	SysErrorMessages:
		Offset0 		db '000:languageONE error' 
						times 64-$+Offset0 db ' '					
	;	Windows error handled by just displaying the error code

	languageONEErrorMessages:
		err01			db 'NUMBERS[error]:- non numeric field'
						times 80-$+err01 db ' '
		err02			db 'NUMBERS[error]:- result has exceeded its range'
						times 80-$+err02 db ' '
		err03			db 'NUMBERS[error]:- use WORDS to convert number to text'
						times 80-$+err03 db ' '
		err04			db 'NUMBERS[error]:- use $equals to convert a word to a number'
						times 80-$+err04 db ' '
		err05			db 'NUMBERS[error]:- Entered field has exceeded its range'
						times 80-$+err05 db ' '	
		err06			db 'NUMBERS[error]:- Result field must have a defined picture'
						times 80-$+err06 db ' '	
		err07			db 'WORDS[error]:- use NUMBERS to convert text to number'
						times 80-$+err07 db ' '
		err08			db 'DECISIONS[error]:- Error comparing Alpha and Numeric field'
						times 80-$+err08 db ' '
		err09			db 'TABLES[error]:- You have not passed a valid table'
						times 80-$+err09 db ' '
		err10			db 'TABLES[error]:- Cannot SORT/SEARCH a multiDimensional table'
						times 80-$+err10 db ' '
		err11			db 'FILES[error]:- a filename has been found that exceeds the system limit'
						times 80-$+err11 db ' '
		err12			db 'NUMBERS[error]:- receiving (ALPHA) too small. Literals default pic is 26'
						times 80-$+err12 db ' '
												
	INSERTWORD 			LF,				02, {0x0D,0x0A}


	insertnumber 		RETURN_CODE,	0,'9999-'
	insertnumber 		ERROR_CODE,		0,'99'	
	insertnumber		WIN_ReturnCode,	0,'99999'
	insertnumber		CHILD_PID,		0,'999999'	
	INSERTNUMBER 		w_One,			1,'9'
	INSERTWORD 			w_Spaces,		128,' '
	INSERTWORD			w_Temp,			128,' '
	
;	Fields for DATE routines
	insertnumber 		w_9Year,		0,'9999'
	insertnumber 		w_9Month,		0,'99'
	insertnumber 		w_9Day,			0,'99'
	insertword 			w_XYear,		4,' '
	insertword 			w_XMonth,		2,' '
	insertword 			w_XDay,			2,' '
	MonthTable			db 31,28,31,30,31,30,31,31,30,31,30,31

;=======================================================================				
;           SKIP STACK
;=======================================================================

;-----------------------------------------------------------------------				
;           UN Initialised - zero filled when loaded
;-----------------------------------------------------------------------													  
			section .bss

savedRegisters	  times 384 resq 1
SX							resq 1
													
							resb 1										; BEGIN.INSTRUCTIONS will set to 'X'	
							resq 1										; Will be set each time it is used
w_RecordBuffer				resb 65536 									; Reserve 64k

w_SaveAddress				resq 1										; General purpose

w_SaveRSP					resq 1										; StackPointer on entry
w_TopOfBSS					resq 1										; Start of $getmem area
w_BottomOfBSS				resq 1										; End of $getmem area

w_ProgramName				resq 256									; Used in _RUN

w_SYSTEMTIME:
	wYear					resw 1
	wMonth					resw 1
	wDayOfWeek				resw 1
	wDay					resw 1
	wHour					resw 1
	wMinute					resw 1
	wSecond					resw 1
	wMilliseconds			resw 1
	
;	------------
;	Used in _RUN
;	------------
	pipeRead				resq 1
	pipeWrite				resq 1

SecurityAttributes:
	nLength					resq 1
	lpSecurityDescriptor	resq 1
	bInheritHandle			resq 1
		
ProcessInformation:
	hProcess				resq 1
	hThread					resq 1	
	dwProcessId				resd 1
	dwThreadId				resd 1
	
StartupInfo:
	cb						resq 1		
	lpReserved				resq 1
	lpDesktop				resq 1
	lpTitle					resq 1		
	dwX						resd 1
	dwY						resd 1
	dwXSize					resd 1
	dwYSize					resd 1
	dwXCountChars			resd 1
	dwYCountChars			resd 1
	dwFillAttribute			resd 1
	dwFlags					resd 1	
	wShowWindow				resw 1
	cbReserved2				resw 1
	filler	 				resd 1
	lpReserved2				resq 1	
	hStdInput				resq 1
	hStdOutput				resq 1
	hStdError				resq 1

;=======================================================================				
;           CONSTANTS
;=======================================================================	
;***Debug Printing
	extern _DISPLAY
   %macro debugPrint 1
		$pushAll r8,r9,r10,r11,r12,r13,r14,r15,rax,rbx,rcx,rdx,rsi,rdi
		$SetupField %1
		Call _DISPLAY
		$SetupField LF
		Call _DISPLAY
		$popAll rdi,rsi,rdx,rcx,rbx,rax,r15,r14,r13,r12,r11,r10,r9,r8
   %endmacro
;***Debug Printing
;=======================================================================
;			CODE SEGMENT
;=======================================================================				
			section .text	
			
			
;=======================================================================
;			ROUTINES TO ASSIST LMACRO.CPY
;=======================================================================
;	This is here to help the Numbers macro. Within the rep preprocessor macro we
;	need to determine if the operand is alpha or numeric. Having decided a jump 
;	would be required which would cause a duplicate label when there are more than
;	one operand. 
;	Note here that we cannot pop values off the stack (pushed by %extract) cuz the
;	call to this routine has pushed the return address. Therefore we address the
;	values directly and pop the stack after returning from this routine
;=======================================================================
No_Assist:

			cmp @fieldIndicator(r_nSrcAddress),'X'						; Alpha or Number source
				je .AlphaSrc

		;	NUMERIC SOURCE
	.1If:	cmp r15,1
				jng .1EndIf
				mov r_nSrcPicAddress,[RSP+8]							; Grab the Picture address						
				mov r_nSrcPicLength,[r_nSrcPicAddress-8]				; 	Picture Length
	.1EndIf:jmp No_Assist_Exit
			
		;	ALPHA SOURCE
	.AlphaSrc:														
			mov r_nSrcStart,w_One										; (Default) address of start position
			mov r_nSrcLength,r_nSrcAddress								; (Default) address of No Of Bytes
			sub r_nSrcLength,8											; its the string length	
	.2If:	cmp r15,2
				jl .2EndIf									
				mov r_nSrcStart,[RSP+8]
			cmp r15,3
				jl .2EndIf
				mov r_nSrcLength,[RSP+16]	
	.2EndIf:	
	
			mov r_nSrcStart,[r_nSrcStart]								; by value
			mov r_nSrcLength,[r_nSrcLength]								; by value	

No_Assist_Exit:
	ret

;=======================================================================			
;           ENVIRONMENT routine - move env variable to a destination
;=======================================================================
;-----------------------------------------------------------------------
;			+--------------------------+  
;			|  Destination Address     |
;			+--------------------------+ r12
;			|  					       |
;			+--------------------------+ r11
;			|  						   |
;			+--------------------------+ r10
;			|  Source Address          |
;			+--------------------------+ r9 
;			|  Function				   |
;			+--------------------------+ r8		
;-----------------------------------------------------------------------	
_ENVIRONMENT:
 
		;	--------------------
		;	Null terminate field
		;	--------------------
			mov rcx,@fieldLength(r9)										; set counter to field len
			dec rcx															; less 1
			std																; working backwards
	.1If:	cmp byte[r9+rcx],0x20											; If there is a space
			loope .1If														;	then loop
			add rcx,2														; get the right spot
			mov byte[r9+rcx],0x00											; null terminate it
		
		;	----------
		;	And get it
		;	----------
  		mov rbx,rsp															; Grab the stack pointer
  		and rsp,0xFFFFFFFFFFFFFFF0											; Align it to 16bytes	
		sub rsp,32															; Create Shadow Stack
		cld																	; Clear Direction Flag
			mov rcx,r9														; rcx = source
			mov rdx,r12														; rdx = destination
			mov r8,@fieldLength(r12)										; r8 = len destination
			Call GetEnvironmentVariableA									; and call it
		mov rsp,rbx		
		
_ENVIRONMENT_EXIT:
			ret
	
;=======================================================================
;			Produce System Error and terminate
;			Error code is in RAX
;			Application Error Message in R14
;=======================================================================				
_SYSERROR:
	[section .data]
		msg1			db 'Windows Error is '
	[section .text]	

		cld
		
	;	-----------------
	;	set output to red
	;	-----------------
  		mov rbx,rsp															; Grab the stack pointer
  		and rsp,0xFFFFFFFFFFFFFFF0											; Align it to 16bytes	
		sub rsp,32															; Create Shadow Stack
		cld																	; Clear Direction Flag
			mov	rcx,qword[StdOutHandle]
			mov rdx,4
			call SetConsoleTextAttribute
		mov rsp,rbx
	
		cmp qword[WIN_ReturnCode],0															
			je .L1

		mov r9,WIN_ReturnCode												; Get the Return Code
		mov r12,w_Temp														; Using w_Temp
		mov r13,[w_One]														; Start at 1
		mov r15,c_TRUE														; Tell _TOALPHA to Set length of Destination
		Call _TOALPHA														; Make the call

  		mov rbx,rsp															; Grab the stack pointer
  		and rsp,0xFFFFFFFFFFFFFFF0											; Align it to 16bytes	
  		push 0
		sub rsp,32															; Create Shadow Stack
		cld																	; Clear Direction Flag
			mov	rcx,qword[StdOutHandle]	
			mov rdx,msg1
			mov r8,17
			mov	r9,RETURN_CODE												; No of Characters Written
			call WriteConsoleA
		mov rsp,rbx	

			
  		mov rbx,rsp															; Grab the stack pointer
  		and rsp,0xFFFFFFFFFFFFFFF0											; Align it to 16bytes	
  		push 0
		sub rsp,32															; Create Shadow Stack
		cld																	; Clear Direction Flag
			mov	rcx,qword[StdOutHandle]	
			mov rdx,w_Temp
			mov r8,5
			mov	r9,RETURN_CODE												; No of Characters Written
			call WriteConsoleA
		mov rsp,rbx
		
  		mov rbx,rsp															; Grab the stack pointer
  		and rsp,0xFFFFFFFFFFFFFFF0											; Align it to 16bytes	
  		push 0
		sub rsp,32															; Create Shadow Stack
		cld																	; Clear Direction Flag
			mov	rcx,qword[StdOutHandle]	
			mov rdx,LF
			mov r8,2
			mov	r9,RETURN_CODE												; No of Characters Written
			call WriteConsoleA
		mov rsp,rbx
		
	;	--------
	;	and EXIT
	;	--------
		jmp .Exit
						
	;	-----------------
	;	languageONE Error
	;	-----------------
	.L1:cmp r14,0
		je .Exit

  		mov rbx,rsp															; Grab the stack pointer
  		and rsp,0xFFFFFFFFFFFFFFF0											; Align it to 16bytes	
  		push 0
		sub rsp,32															; Create Shadow Stack
		cld																	; Clear Direction Flag
			mov	rcx,qword[StdOutHandle]	
			mov rdx,SysErrorMessages
			mov r8,21
			mov	r9,RETURN_CODE												; No of Characters Written
			call WriteConsoleA
		mov rsp,rbx
		
  		mov rbx,rsp															; Grab the stack pointer
  		and rsp,0xFFFFFFFFFFFFFFF0											; Align it to 16bytes	
  		push 0
		sub rsp,32															; Create Shadow Stack
		cld																	; Clear Direction Flag
			mov	rcx,qword[StdOutHandle]	
			mov rdx,LF
			mov r8,2
			mov	r9,RETURN_CODE												; No of Characters Written
			call WriteConsoleA
		mov rsp,rbx
		
  		mov rbx,rsp															; Grab the stack pointer
  		and rsp,0xFFFFFFFFFFFFFFF0											; Align it to 16bytes	
  		push 0
		sub rsp,32															; Create Shadow Stack
		cld																	; Clear Direction Flag
			mov	rcx,qword[StdOutHandle]	
			mov rdx,r14
			mov r8,72
			mov	r9,RETURN_CODE												; No of Characters Written
			call WriteConsoleA
		mov rsp,rbx
		
  		mov rbx,rsp															; Grab the stack pointer
  		and rsp,0xFFFFFFFFFFFFFFF0											; Align it to 16bytes	
  		push 0
		sub rsp,32															; Create Shadow Stack
		cld																	; Clear Direction Flag
			mov	rcx,qword[StdOutHandle]	
			mov rdx,LF
			mov r8,2
			mov	r9,RETURN_CODE												; No of Characters Written
			call WriteConsoleA
		mov rsp,rbx
		
	.Exit:
		xor	rcx,rcx
		call ExitProcess	

_SYSERROR_EXIT:
			ret

;=======================================================================				
;           Validate and correct SOURCE/DESTINATION calling parameters
;=======================================================================			
;-----------------------------------------------------------------------
;			+-------------------+
;			|  Replace/Find     |
;			+-------------------+ r15	
;			|  Zero             | 		
;			+-------------------+ r14 	
;			|  DestinationStart |		
;			+-------------------+ r13 	 	
;			|  Destination      |	   For Number to Alpha		
;			+-------------------+ r12 +-------------------+
;			|  No Of Bytes      |	  |  Picture Length   |
;			+-------------------+ r11 +-------------------+
;			|  SourceStart      |	  |  Picture Address  |
;			+-------------------+ r10 +-------------------+
;			|  Source1          |
;			+-------------------+ r9  
;			|  Function         |
;			+-------------------+ r8  1st Parameter
;-----------------------------------------------------------------------

_VALIDATE_SRC:
		
;-----------------------------------------------------------------------			                  
;           Validate the Source Parameters
;-----------------------------------------------------------------------
		;	Validate source is only for an Alpa source
		;	It will not be called when the source is numeric
			cmp @fieldIndicator(r9),'9'
				je _VALIDATE_SRC_EXIT
							
;           START
	ss1:	cmp r_SrcStart,0											; Compare the SourceStart to 0 
				jne ss2
				mov r_SrcStart,1										; Reset to 1
				
	ss2:	cmp r_SrcStart,65536										; Limit string size to 65535 - this will also filter out -ve
				jb ss3
			    mov r_SrcStart,1										; Reset to 1		

	ss3:	cmp r_SrcStart,@fieldLength(r_SrcAddress)					; Compare the SourceStart to length of string	
				jbe se1
				mov r_SrcStart,@fieldLength(r_SrcAddress)				; Reset to length of string 

;           NO OF BYTES						
	se1:	cmp r_SrcLength,0											; Compare the Source No Of Bytes to 0
				jg  se2
				mov r_SrcLength,@fieldLength(r_SrcAddress)				; length of string
				sub r_SrcLength,r_SrcStart								;	less start
				inc r_SrcLength											;	+ 1
	
	se2:	cmp r11,65536												; Limit string size to 65535 - this will also filter out -ve
				jb  se3
				mov r_SrcLength,1
				
	se3:	mov rax,r_SrcStart											; Compare the Source start
			add rax,r_SrcLength											;	plus No of bytes
			dec rax														;	less 1
			cmp rax,@fieldLength(r_SrcAddress)					
				jbe _VALIDATE_SRC_EXIT
				mov r_SrcLength,@fieldLength(r_SrcAddress)				; Reset to length of string			
				sub r_SrcLength,r_SrcStart								;	less start
				inc r_SrcLength											;	+ 1

_VALIDATE_SRC_EXIT:
			ret
						
;-----------------------------------------------------------------------			
;           Validate the Destination Parameters
;-----------------------------------------------------------------------
_VALIDATE_DST:

	ds1:	cmp	r_DstStart,0											; Compare the DestinationStart to 0 
				jg ds2
				mov r_DstStart,1										; Reset to 1  

	ds2:	cmp r_DstStart,65536										; Destination start
				jb ds3
				mov r_DstStart,1										; Reset to 1
							
	ds3:	cmp r_DstStart,@fieldLength(r_DstAddress)					; Compare the DestinationStart to length of string	
				jbe ds4
				mov r_DstStart,@fieldLength(r_DstAddress)				; Reset to length of string
				sub r_DstStart,r_SrcLength								;	less No Of Bytes
				inc r_DstStart											;	+ 1  
				 		
	ds4:
_VALIDATE_DST_EXIT:
			ret

;=======================================================================				
;           Date routines
;			DATE_TO_DAYS (Number,String*10) This where Validation is done
;			DAYS_TO_DATE (Number,String*10)
;=======================================================================

;		Unix time (also known as POSIX time or Epoch time) is a system 
;		for describing instants in time, defined as the number of seconds 
;		that have elapsed since 00:00:00 Coordinated Universal Time (UTC), 
;		Thursday, 1 January 1970

;		In the Gregorian calendar, a normal year consists of 365 days.
;		Because the actual length of a sidereal year (the time required for the
;		Earth to revolve once about the Sun) is actually 365.25635 days, 
;		a "leap year" of 366 days is used once every four years to eliminate
;		the error caused by three normal (but short) years. 
;		Any year that is evenly divisible by 4 is a leap year: 
;		for example, 1988, 1992, and 1996 are leap years.

;		However, there is still a small error that must be accounted for. 
;		To eliminate this error, the Gregorian calendar stipulates that a year 
;		that is evenly divisible by 100 (for example, 1900) is a leap year only 
;		if it is also evenly divisible by 400.

;		For this reason, the following years are not leap years:
;		1700, 1800, 1900, 2100, 2200, 2300, 2500, 2600
;		This is because they are evenly divisible by 100 but not by 400.

;		The following years are leap years: 1600, 2000, 2400
;		This is because they are evenly divisible by both 100 and 400. 
;
;		**** OTHER THAN DIVIDING BY 4 WE DONT CARE AS THE NEXT ADJUSTMENT
;		**** IS DUE IN 2100. (Year 2K bug all over again !!!!!!)

;-----------------------------------------------------------------------
;		DATE mainline
;-----------------------------------------------------------------------				
_DATE:
		%define r_NoOfDays	 r9
		%define r_DateString r10

			
		;	------------------------------
		;	Just get Seconds
		;	------------------------------
			cmp r_Function,-1
				jne .DateFunctions

				Call _GETDATE												; Get system date
				xor  rax,rax												; Clear rax
				mov  ax,word[wHour]											; get Hours from midnight
				imul rax,60													; into minutes
				add  ax,word[wMinute]										; add minutes
				imul rax,60													; into seconds
				add  ax,word[wSecond]										; add seconds
				mov  qword[r9],rax											; and store it
				jmp _DATE_EXIT												; and exit			

		;	-------------------------------
		;	DATE Functions
		;	-------------------------------
	.DateFunctions:
			cmp r_Function,1														
				jb .GetDate												; Get Date
				je .Date												; Days To Date
				ja .Days												; Date To Days
			
	.GetDate:	Call _GETDATE											; Get the number of days and fall thru
				jmp .Exit												; for Windows version
				
	.Date:		Call _DATEFROMDAYS										; Convert Days to Date
				jmp .Exit
								
	.Days:		Call _DAYSFROMDATE										; Convert Date to Daye
				jmp .Exit
			
	.Exit:		mov byte[MonthTable+1],28								; Reset February
	
_DATE_EXIT:
		ret
					
;-----------------------------------------------------------------------
;		GET SYSTEM DATE
;		returns a date and Days from the Linux epoch	
;		Linux epoch starts at =	Thursday, 1 January 1970 @ 00:00:00
;-----------------------------------------------------------------------
global _GETDATE
_GETDATE:

		$pushAll r8,r9,r10,r11,rax,rcx,rdx
  		mov rbx,rsp															; Grab the stack pointer
  		and rsp,0xFFFFFFFFFFFFFFF0											; Align it to 16bytes	
		sub rsp,32															; Create Shadow Stack
		cld																	; Clear Direction Flag
			mov	rcx,w_SYSTEMTIME
			call GetLocalTime
		mov rsp,rbx	
		$popAll rdx,rcx,rax,r11,r10,r9,r8		

		cmp r_Function,-1													; Only getting seconds
			je .Exit	

		xor r12,r12
		mov r12w,word[wYear]												; Grab the Year
		xor r13,r13
		mov r13w,word[wMonth]												; Grab the Month
		xor r14,r14
		mov r14w,word[wDay]													; Grab the Days
		Call _DATETOALPHA													; Convert to Alpha
		Call _DAYSFROMDATE													; and get the no of days

	.Exit:	
_GETDATE_EXIT:
		ret

;-----------------------------------------------------------------------
;		CONVERT DAYS TO DATE
;		Linux epoch starts at 
;		Thursday, 1 January 1970 @ 00:00:00
;-----------------------------------------------------------------------
_DATEFROMDAYS:		

	%define r_Year		 r12
	%define r_Month		 r13
	%define r_Day		 r14
		
			mov r_Year,1970												; Start Count at 1970
			mov rax,[r_NoOfDays]										; Grab the No Of Days
			mov rbx,2													; count the leapyears from 1970
		;	---------------------------------------
	.YearLoop:
		;	---------------------------------------
			cmp rax,367													; If we are at 365 or 366
				jb .YearLoopExit										; 	then exit the loop
				
			cmp rbx,4													; If we have hit a leapyear
				je .Leap												;	then jmp to process it
			sub rax,365													; ELSE subtract 365 days 
			jmp .Cont													;	and jump to continue
	.Leap:	sub rax,366													; Subtract 366 days
			xor rbx,rbx													; and restart the leap year count
	.Cont:	inc r_Year													; INCREMENT the Year
			inc rbx														; INCREMENT the Leap Year counter
			jmp .YearLoop												;  and loop
		;	----------------------------------------
	.YearLoopExit:
		;	----------------------------------------
		;	ARE WE CURRENTLY IN A LEAP YEAR
	.1if:	cmp rbx,4													; If NOT LeapYear
				jne .1else												;	then jump over
				mov byte[MonthTable+1],29								; Else set Feb to 29
				jmp .1endif
	.1else:	cmp rax,366													; If we havent hit 366
			jb .1endif													;	then exit
				inc r_Year												; ELSE flicked over a year
				mov rax,1												;	set remaining days to 1				
	.1endif:				
		
			xor r_Month,r_Month											; Count No of Months
			xor rdx,rdx													; Zero the month no
		;	----------------------------------------
	.MonthLoop:
		;	----------------------------------------
			mov dl,byte[MonthTable+r_Month]								; Grab the No Of Days in the month
			inc r_Month													; Go to the next month			
			cmp rax,rdx													; If we done
				jb .MonthLoopExit										;	then exit loop
			sub rax,rdx													; Subtract the No Of Days in the month	
			jmp .MonthLoop												;	and loop
		;	-----------------------------------------
	.MonthLoopExit:
		;	-----------------------------------------

		;	And the days are left over
			inc rax														; ????????????????????????????????
			mov r_Day,rax												; Store the remainder as No Of Days
			Call _DATETOALPHA											; and Load the date inti the alpha field

_DATEFROMDAYS_EXIT:
		ret       		


;-----------------------------------------------------------------------
;		LOAD THE EXTRACTED DATE INTO TH ALPHA FIELD
;-----------------------------------------------------------------------
_DATETOALPHA:

		;	Store the passed fields
			PUSH R9
			push R10													
			
		;	Store the Day/Month/Year values in languageONE numeric fields	
			mov qword[w_9Year], r_Year
			mov qword[w_9Month],r_Month
			mov qword[w_9Day],  r_Day			
		;	Setup registers appropriately for call to _TOALPHA	
			xor r10,r10
			xor r11,r11
			xor r14,r14
			xor r15,r15
			mov r13,1
		;	Convert Years(number) to Years(alpha)	
			mov r9,w_9Year
			mov r12,w_XYear
			xor r10,r10
			xor r11,r11
	mov r15,c_FALSE					; No need to resize			
			Call _TOALPHA
		;	Convert Months(number) to Years(alpha)
			mov r9,w_9Month
			mov r12,w_XMonth
			xor r10,r10
			xor r11,r11
	mov r15,c_FALSE					; No need to resize
			Call _TOALPHA
		;	Convert Days(number) to Days(alpha)
			mov r9,w_9Day
			mov r12,w_XDay
			xor r10,r10
			xor r11,r11
	mov r15,c_FALSE					; No need to resize			
			Call _TOALPHA

		;	RestStore the passed fields
			POP R10
			POP R9	
			cld
						
		;	Now concatenate individual fields into one
			mov RSI,w_XYear												; Setup source address			
			mov RDI,r10													; Setup destination address
			mov rcx,4													; CCYY to move
	.l1:	movsb														; and do it
			loop .l1

		;	Add a forward slash
			inc RDI														; Next character
			mov byte[RDI],'/'											; move the slash
			
		;	Now do the months	
			mov RSI,w_XMonth											; Reset the source address
			mov rcx,2													; MM to move
	.l2:	movsb														; and do it
			loop .l2

		;	And add a forward slash
			inc RDI														; Next character
			mov byte[RDI],'/'											; move the slash
			
		;	And finally the days	
			mov RSI,w_XDay												; Reset the source address		
			mov rcx,2													; DD to move
	.l3:	movsb														; and do it
			loop .l3

_DATETOALPHA_EXIT:
		ret
		
;-----------------------------------------------------------------------
;		CONVERT DATE TO DAYS
;		Linux epoch starts at 
;		Thursday, 1 January 1970 @ 00:00:00
;-----------------------------------------------------------------------	 
_DAYSFROMDATE:

			Call _ALPHATODATE
	
		;	Validate
			cmp r_Year,1970												; < 1970. Outside of epoch
				jb .Error
			cmp r_Month,1												; < 1. Invalid month
				jb .Error
			cmp r_Month,12												; > 12. Invalid month
				ja .Error
			cmp r_Day,1													; < 1. Invalid Month
				jb .Error
								
			mov rax,r_Year												; Grab the year
			mov rbx,4													; To divide by 4
			xor rdx,rdx													; Clear rdx
			div rbx														; and divide
			cmp rdx,0													; No remainder then no leap year
				jne .day												; So jump
			mov byte[MonthTable+1],29									; Set Feb as 29 days
	.day:	xor rcx,rcx
			mov cl,byte[MonthTable+r_Month-1]							; Do the compare
			cmp r_Day,rcx												; and error if too many days
				ja .Error


		;	Calculate days in year
			xor rdx,rdx													; For counting the no of days
			mov rax,1970												; Start Count at 1970
			mov rbx,2													; count the leapyears from 1970
		;	---------------------------------------
	.YearLoop:
		;	---------------------------------------
			cmp rax,r_Year												; If we have done all the years
				je .YearLoopExit										; 	then exit the loop
				
			cmp rbx,4													; If we have hit a leapyear
				je .Leap												;	then jmp to process it
			add rdx,365													; ELSE add 365 days 
			jmp .Cont													;	and jump to continue
	.Leap:	add rdx,366													; add 366 days
			xor rbx,rbx													; and restart the leap year count
	.Cont:	inc rax														; INCREMENT the Year
			inc rbx														; INCREMENT the Leap Year counter
			jmp .YearLoop												;  and loop
		;	----------------------------------------
	.YearLoopExit:


			mov rcx,r_Month												; Loop counter
			dec rcx														; less 1
			mov rsi,MonthTable											; Month Offset
		;	----------------------------------------
	.MonthLoop:
		;	----------------------------------------
			xor r15,r15													; Clear r15
			mov r15b,byte[rsi]											; Grab the No Of Days in the month
			add rdx,r15													; Add the No Of Days in the month	
			inc rsi														; Go to the next month
			loop .MonthLoop												;	and loop
		;	-----------------------------------------
		;	-----------------------------------------

		;	Calculating the no of days between two dates ie 1970/01/01 and a future date
		;	then we dont include the future day - so dec rdx (no Of Days)
			add rdx,r_Day												; Add the days
			dec rdx														; less 1
			mov qword[r_NoOfDays],rdx									; move to output
			jmp _DAYSFROMDATE_EXIT										; and exit

		;	-----------------------------------------
		;	ERROR
		;	-----------------------------------------
	.Error:	mov QWORD[ERROR_CODE],1
			
_DAYSFROMDATE_EXIT:
		ret

;-----------------------------------------------------------------------
;		LOAD THE ALPHA DATE INTO NUMERIC FIELDS
;-----------------------------------------------------------------------
_ALPHATODATE:
			cld
			
		;	Extract date into individual fields
			mov RSI,r_DateString										; Setup source address			
			mov RDI,w_XYear												; Setup destination address
			mov rcx,4													; CCYY to move
	.l1:	movsb														; and do it
			loop .l1

		;	Skip forward slash
			inc RSI														; Next character
			
		;	Now do the months	
			mov RDI,w_XMonth											; Reset the destination address
			mov rcx,2													; MM to move
	.l2:	movsb														; and do it
			loop .l2

		;	Skip forward slash
			inc RSI														; Next character
			
		;	And finally the days	
			mov RDI,w_XDay												; Reset the destination address		
			mov rcx,2													; DD to move
	.l3:	movsb														; and do it
			loop .l3

		;	Store the passed fields
			PUSH R9														
			PUSH R10													
																
		;	Store the Day/Month/Year values in languageONE numeric fields				
		;	Setup registers appropriately for call to _FROMALPHA
			mov r9,w_9Year
			xor r10,r10
			xor r11,r11
			mov r12,w_XYear
			mov r13,1
			mov r14,4
		;	Convert Years(number) to Years(alpha)	
			Call _FROMALPHA			
		;	Convert Months(number) to Years(alpha)
			mov r9,w_9Month
			mov r12,w_XMonth
			mov r14,2
			Call _FROMALPHA
		;	Convert Days(number) to Days(alpha)
			mov r9,w_9Day
			mov r12,w_XDay
			Call _FROMALPHA

		;	RestStore the passed fields
			POP R10
			POP R9	

		;	move languageONE fields to registers
			mov r_Year, qword[w_9Year]
			mov r_Month,qword[w_9Month]
			mov r_Day,  qword[w_9Day]						
			
_ALPHATODATE_EXIT:
		ret

;=======================================================================	
;		RUN and WAIT
;=======================================================================
;-----------------------------------------------------------------------
;		RUN_BATCH
;-----------------------------------------------------------------------
_RUN_INTERACTIVE:
_RUN_INTERACTIVE_EXIT:
		ret
;-----------------------------------------------------------------------
;		RUN_BATCH
;-----------------------------------------------------------------------
_RUN_BATCH:
			mov r14,r9														; Save Path
			mov r15,r10														; Save File Address
			mov qword[ERROR_CODE],0											; Clear Error Code

		;	---------------------------------------------------------
		;	Set the bInheritHandle flag so pipe handles are inherited
		;	---------------------------------------------------------
			mov dword[nLength],24	
			mov qword[lpSecurityDescriptor],0x00
			mov dword[bInheritHandle],1
			
		;	-----------
		;	CREATE PIPE
		;	-----------
		;	CreatePipe(&pipeRead, &pipeWrite, &saAttr, 0);
  		mov rbx,rsp															; Grab the stack pointer
  		and rsp,0xFFFFFFFFFFFFFFF0											; Align it to 16bytes	
		sub rsp,32															; Create Shadow Stack
		cld																	; Clear Direction Flag
			mov rcx,pipeRead
			mov rdx,pipeWrite
			mov r8,SecurityAttributes
			xor r9,r9
			Call CreatePipe
		mov rsp,rbx
			cmp rax,1
				jne .err
				
;	.If1:	cmp rax,1
;				je .Else1
;				Call GetLastError
;				mov qword[WIN_ReturnCode],rax
;				Call _SYSERROR
;	.Else1:
				push qword[pipeRead]										; Return Read Handle
				pop  qword[r15-25]
;	.EndIf1:	

		;	---------------------------------
		;	Clear StartupInfo and ProcessInfo			
		;	---------------------------------
			mov rdi,StartupInfo
			xor rax,rax
			mov rcx,13
		rep stosq
			mov dword[cb],104

			mov rdi,ProcessInformation
			xor rax,rax
			mov rcx,3
		rep stosq
			
		;	-----------------
		;	Setup StartupInfo			
		;	-----------------
			mov dword[dwFlags],0x00000100 									; STARTF_USESTDHANDLES
			mov rax,qword[pipeWrite]
			mov qword[hStdOutput],rax
			mov qword[hStdError],rax
	
		;	-------------------
		;	DONT INHERIT READ ?
		;	-------------------
		;	SetHandleInformation(g_hChildStd_OUT_Rd, HANDLE_FLAG_INHERIT, 0);
  		mov rbx,rsp															; Grab the stack pointer
  		and rsp,0xFFFFFFFFFFFFFFF0											; Align it to 16bytes	
		sub rsp,32															; Create Shadow Stack
		cld																	; Clear Direction Flag
			mov rcx,qword[pipeRead]
			mov rdx,1
			xor r8,r8
			Call SetHandleInformation
		mov rsp,rbx
			cmp rax,1
				jne .err

;	.If2:	cmp rax,1
;				je .EndIf2
;				Call GetLastError
;				mov qword[WIN_ReturnCode],rax
;				Call _SYSERROR
;	.EndIf2:	

		;	--------------
		;	CREATE PROCESS
		;	--------------
  		mov rbx,rsp															; Grab the stack pointer
  		and rsp,0xFFFFFFFFFFFFFFF0											; Align it to 16bytes
		;	CreateProcess( NULL,"C:\Windows\System32\cmd.exe /c dir",NULL,NULL,TRUE,0,0,0,&si,&pi); 
			push ProcessInformation											; lpProcessInformation
			push StartupInfo												; lpStartupInfo
			push 0															; lpCurrentDirectory
			push 0															; lpEnvironment
			push 0															; dwCreationFlags
			push 1															; bInheritHandles
		sub rsp,32															; Create Shadow Stack
		cld																	; Clear Direction Flag
			xor rcx,rcx														; Take progname from path
			mov rdx,r14														; Path/Program
			xor r8,r8														; lpSecurityAttributes
			xor r9,r9														; lpThreadAttributes
			Call CreateProcessA
		mov rsp,rbx
			cmp rax,1
				jne .err
		
;	.If3:	cmp rax,1
;				je .Else3
;				Call GetLastError
;				mov qword[WIN_ReturnCode],rax
;				Call _SYSERROR
;	.Else3:
				push qword[hProcess]										; Populate Child PID	
				pop  qword[CHILD_PID]
;	.EndIf3:	
			jmp .Exit

		;	-----------------------------	
	.err:	;	ERROR MESSAGE
		;	-----------------------------						
			Call GetLastError
			mov qword[WIN_ReturnCode],rax
			Call _SYSERROR

	.Exit:
_RUN__BATCH_EXIT:
			ret

;-----------------------------------------------------------------------
;		WAIT
;-----------------------------------------------------------------------
_WAIT:

		;	----
		;	WAIT
		;	----
  		mov rbx,rsp															; Grab the stack pointer
  		and rsp,0xFFFFFFFFFFFFFFF0											; Align it to 16bytes	
		sub rsp,32															; Create Shadow Stack
		cld																	; Clear Direction Flag
			mov rcx,qword[r9]												; Process ID
			or edx,0xFFFFFFFF												; INFINITE
			Call WaitForSingleObject
		mov rsp,rbx

	.If1:	cmp rax,0
				je .EndIf1
				Call GetLastError
				mov qword[WIN_ReturnCode],rax
				Call _SYSERROR
	.EndIf1:	

		;	----------
		;	CLOSE PIPE
		;	----------
  		mov rbx,rsp															; Grab the stack pointer
  		and rsp,0xFFFFFFFFFFFFFFF0											; Align it to 16bytes	
		sub rsp,32															; Create Shadow Stack
		cld																	; Clear Direction Flag
			mov rcx,qword[pipeWrite]										; Set File Handle	
			Call CloseHandle
		mov rsp,rbx
	
_WAIT_EXIT:
			ret
			
;-----------------------------------------------------------------------
;		GET A RANDOM NUMBER
;		Although this would be best in NUMBERS.LIB, by having it here
;		I do not have to split NUMBERS.LIB into OS versions
;-----------------------------------------------------------------------
_RANDOM:

	[section .data]
		align 4																; Will fail unless aligned
			_random 				dq 0									; on dword

	[section .text]	
		push r10
		
  		mov rbx,rsp															; Grab the stack pointer
  		and rsp,0xFFFFFFFFFFFFFFF0											; Align it to 16bytes	
		sub rsp,32															; Create Shadow Stack
		cld																	; Clear Direction Flag
			mov rcx,_random
			Call QueryPerformanceCounter
		mov rsp,rbx

		xor rax,rax
		mov ax,word[_random]												; Grab one half
		xor rbx,rbx
		mov bx,word[_random+2]												; grab the other half
		xor ax,bx															; Xor them
		
		pop r10
		mov qword[r10],rax													; and return the value

_RANDOM_EXIT:
			ret

			;-----------------------------------------------------------------------
;		STRING COMPARE
;-----------------------------------------------------------------------
_CMPSTR:

;	----------
;	QUAD WORDS
;	----------
	.quad:
		cmp rcx,8
			jl .double
			
		mov rax,qword[rsi]
		bswap rax
		mov rbx,qword[rdi]
		bswap rbx
		cmp rax,rbx
			jne _CMPSTR_EXIT
		
		add rsi,8
		add rdi,8
		sub rcx,8
		jmp .quad

;	------------
;	DOUBLE WORDS
;	------------		
	.double:
		cmp rcx,4
			jl .word

		mov eax,dword[rsi]
		bswap eax
		mov ebx,dword[rdi]
		bswap ebx
		cmp eax,ebx
			jne _CMPSTR_EXIT
			
		add rsi,4
		add rdi,4
		sub rcx,4
		jmp .double
		
;	-----
;	WORDS
;	-----			
	.word:
		cmp rcx,2
			jl .byte

		mov ax,word[rsi]
		xchg ah,al
		mov bx,word[rdi]
		xchg bh,bl
		cmp ax,bx
			jne _CMPSTR_EXIT
			
		add rsi,2
		add rdi,2
		sub rcx,2
		jmp .word
		
;	-----
;	BYTES
;	-----
;	When you are here you maybe looking at the last byte OR you are finished and have equality.
;	In the 2nd case you do not want to destroy the compare result so we step back to the last
;	byte to make sure we do another compare
	.byte:			
		cmp rcx,1
			je .setFlag
		dec rsi
		dec rdi
	.setFlag:		
		mov ah,byte[rsi]
		mov al,byte[rdi]
		cmp ah,al

_CMPSTR_EXIT:
	ret

;-----------------------------------------------------------------------
;		STRING MOVE
;-----------------------------------------------------------------------
_MOVESTR:

;	----------
;	QUAD WORDS
;	----------
	.quad:
		cmp rcx,8
			jl .double
			
		mov rax,qword[rsi]
		mov qword[rdi],rax
		
		add rsi,8
		add rdi,8
		sub rcx,8
		jmp .quad

;	------------
;	DOUBLE WORDS
;	------------		
	.double:
		cmp rcx,4
			jl .word

		mov eax,dword[rsi]
		mov dword[rdi],eax
			
		add rsi,4
		add rdi,4
		sub rcx,4
		jmp .double
		
;	-----
;	WORDS
;	-----			
	.word:
		cmp rcx,2
			jl .byte

		mov ax,word[rsi]
		mov word[rdi],ax
			
		add rsi,2
		add rdi,2
		sub rcx,2
		jmp .word
		
;	-----
;	BYTES
;	-----	
	.byte:
		cmp rcx,1
			jl _MOVESTR_EXIT
			
		mov ah,byte[rsi]
		mov byte[rdi],ah


_MOVESTR_EXIT:
	ret

;-----------------------------------------------------------------------
;		END PROGRAM
;-----------------------------------------------------------------------
_ENDPROGRAM:

  		mov rbx,rsp															; Grab the stack pointer
  		and rsp,0xFFFFFFFFFFFFFFF0											; Align it to 16bytes	
		sub rsp,32															; Create Shadow Stack
		cld																	; Clear Direction Flag
			mov	rcx,qword[ERROR_CODE]
			call ExitProcess

_ENDPROGRAM_EXIT:
			ret
			