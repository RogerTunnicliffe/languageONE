	%include '../include/LMACROS.CPY'
	%include '../include/IMACROS.CPY'
	%include '../include/CONSTANTS.INC'
	%line 4 w_XTABLES.LIB

;	=================================================
;	GLOBAL ROUTINES/VARIABLES defined in this library
;	=================================================
;	Routines
;	--------
	global _XTABLES

;	===============================================
;	EXTERNAL ROUTINES/VARIABLES used by the library
;	===============================================
;	Windows
;	------- 
	extern HeapCreate
	extern HeapAlloc
	extern CreateFileA
	extern ReadFile
	extern WriteFile
	extern GetLastError
	extern CloseHandle

;	-----------------
;	languageONE
;	-----------------
;	Routines
;	--------
	extern _SYSERROR				; COMMON
	extern _TOALPHA					; NUMBERS
	extern _FROMALPHA				; NUMBERS
	extern _CMPSTR					; COMMON
	
;	------
;	Fields
;	------
	extern ERROR_CODE				; COMMON
	extern err09					; COMMON
	extern err10					; COMMON
	extern w_One					; COMMON
	extern w_Temp					; COMMON
	extern w_RecordBuffer			; COMMON
	extern w_TopOfBSS				; COMMON
	extern w_BottomOfBSS			; COMMON
	extern WIN_ReturnCode			; COMMON
;	extern byteCount				; FILES

;=======================================================================
;			Call parameters for _XTABLES
;=======================================================================
;=======================================================================
;       	Macros to create storage for XTABLES
;			INSERTXTABLE WorkTable,Record,Size
;=======================================================================
;-----------------------------------------------------------------------
; 	UBOUND				 STATUS 				 Table Indicator									 
;	+---+---+---+---+---+---+---+---+---+---+---------------+---+---------+------+	     
;	| 1	|'9'|Len|Val|Pic| 1	|'9'|Len|Val|Pic|Record Address	|'T'|NoOfBytes| NAME |
;	+---+---+---+---+---+---+---+---+---+---+---------------+---+---------+------+
;	-61					-27					-17				-9	-8			0	  

;		INSERTXTABLE WorkTable,A01_Record_Length*NoOfRecords
;-----------------------------------------------------------------------
;				   	R8		R9		  R10		R11,R12			R13
;			XTABLES bind,	WorkTable,Record,	Size
;			XTABLES sort,  	WorkTable,Start,	End,Divisor
;			XTABLES search,	WorkTable,Start,	End,SearchItem,	Index
;			XTABLES load,	WorkTable,File,		IncludeDeletedRecs
;			XTABLES load,	WorkTable,File,		IncludeDeletedRecs
;			XTABLES rget, 	WorkTable,Idx
;			XTABLES rput, 	WorkTable,Idx
;			XTABLES delete,	WorkTable,Idx
;					R8		R9		  R11	  R12		R10
;			XTABLES fget,	WorkTable,FieldNo,Fieldname,Idx
;			XTABLES fput,	WorkTable,FieldNo,Fieldname,Idx
;					R8		R9		  R10	  R11
;-----------------------------------------------------------------------
;=======================================================================
;			DATA SEGMENT
;=======================================================================
;           Initialised - by program
;-----------------------------------------------------------------------
			section .data
	INSERTNUMBER I,					0,'999999999'
;-----------------------------------------------------------------------				
;           UN Initialised - zero filled when loaded
;-----------------------------------------------------------------------												  
			section .bss
dq_Nulls					resq 1
dq_IncludeDeletedRecords	resq 1
saveRecLength				resq 1
	byteCount				resd 1
	
;=======================================================================				
;           CONSTANTS
;=======================================================================	
;***Debug Printing
	extern _DISPLAY
	extern _VALIDATE_SRC
	extern LF
	extern w_One
   %macro debugPrint 1
		$pushAll r8,r9,r10,r11,r12,r13,r14,r15,rax,rbx,rcx,rdx,rsi,rdi
		$SetupField %1
		Call _DISPLAY
		$SetupField LF
		Call _DISPLAY
		$popAll rdi,rsi,rdx,rcx,rbx,rax,r15,r14,r13,r12,r11,r10,r9,r8
   %endmacro
;***Debug Printing
;=======================================================================
;			CODE SEGMENT
;=======================================================================				
			section .text	

	%define @tableSize(x)		qword[x-8]
	%define @recordAddress(x)	qword[x-17]
	%define @tableStatus(x)		qword[x-27]
	%define @tableUbound(x)		qword[x-61]

_XTABLES:
			cld
			
;-----------------------------------------------------------------------
;			BIND
;-----------------------------------------------------------------------			
	.bind:	cmp r8,$bind
				jne .functions						
			Call _XBIND
			jmp _XTABLES_EXIT

	.functions:
		.1If:cmp @fieldIndicator(r_Table) ,'T'							; Must be a 'T'able
				je .sort
				xor rax,rax												
				mov r14,err09											; err09 to languageONE error
				Call _SYSERROR											; and call it
		.1EndIf:			
										
;-----------------------------------------------------------------------
;			SORT
;-----------------------------------------------------------------------						
	.sort:	cmp r8,$sort
				jne .find
		;	V2.11
		;	Call _XSORT
		;	V2.11
			Call _QUICKSORT
			jmp _XTABLES_EXIT

;-----------------------------------------------------------------------
;			SEARCH
;-----------------------------------------------------------------------						
	.find:	cmp r8,$search
				jne .load						
			Call _XSEARCH
			jmp _XTABLES_EXIT

;-----------------------------------------------------------------------
;			LOAD
;-----------------------------------------------------------------------			
	.load:	cmp r8,$load		
				jne .unload
			Call _XLOAD
			jmp _XTABLES_EXIT

;-----------------------------------------------------------------------
;			UNLOAD
;-----------------------------------------------------------------------			
	.unload:cmp r8,$unload		
				jne .offs
			Call _XUNLOAD
			jmp _XTABLES_EXIT

;-----------------------------------------------------------------------
;			OFFSET - Calc offset from index
;-----------------------------------------------------------------------						
	.offs:	Call _XOFFSET	
			cmp @tableStatus(r_Table),0
				jne _XTABLES_EXIT							

;-----------------------------------------------------------------------
;			rPUT
;-----------------------------------------------------------------------			
	.rput:	cmp r8,$rput		
				jne .rget
			Call _FROM_RECORD
			jmp _XTABLES_EXIT

;-----------------------------------------------------------------------
;			rGET
;-----------------------------------------------------------------------								
	.rget:	cmp r8,$rget
				jne .delete
			Call _TO_RECORD	
			cmp @tableStatus(r_Table),23
				je _XTABLES_EXIT			

;-----------------------------------------------------------------------
;			DELETE (Will have done a get first)
;-----------------------------------------------------------------------			
	.delete:cmp r8,$del	
				jne .fput
			Call _DELETE
			jmp _XTABLES_EXIT

;-----------------------------------------------------------------------
;			fPUT
;-----------------------------------------------------------------------			
	.fput:	cmp r8,$fput		
				jne .fget
			Call _FPUT
			jmp _XTABLES_EXIT

;-----------------------------------------------------------------------
;			fGET
;-----------------------------------------------------------------------								
	.fget:	cmp r8,$fget
				jne _XTABLES_EXIT
			Call _FGET	
								
_XTABLES_EXIT:
			ret

;=======================================================================
;      		(BIND) Setup TABLE data structure
;=======================================================================
; 	UBOUND				 STATUS 				 Table Indicator									 
;	+---+---+---+---+---+---+---+---+---+---+---------------+---+---------+------+	     
;	| 1	|'9'|Len|Val|Pic| 1	|'9'|Len|Val|Pic|Record Address	|'T'|NoOfBytes| NAME |
;	+---+---+---+---+---+---+---+---+---+---+---------------+---+---------+------+
;	-61					-27					-17				-9	-8			0	
;-----------------------------------------------------------------------
;		r8	 r9			r10			r11			
;		BIND WorkTable, A01_Record, Size
;-----------------------------------------------------------------------
_XBIND:
		;	The BIND process fills in the Table values cuz Tables are 
		;	defined in BSS section and therefore cannot have values.

		; 	Identify as a table
		;	-------------------
			mov @fieldIndicator(r_Table) ,'T'								; Set Table identifier

		;	Uboundary
		;	---------
			mov qword[r_Table-078],1										; UBOUND is integer
			mov  byte[r_Table-070],'9'										; Indicates numeric data structure
			mov qword[r_Table-069],9										; 9 characters long
			mov qword[r_Table-061],0										; UBOUND
			mov al,'9'														; Create picture
			lea RDI,[r_Table-053]
			mov rcx,9
		.l1:stosb
			loop .l1
			
		;	Table Status
		;	------------
			mov qword[r_Table-044],1										; STATUS is integer
			mov  byte[r_Table-036],'9'										; Indicates numeric data structure
			mov qword[r_Table-035],2										; 2 characters long
			mov qword[r_Table-027],0										; STATUS
			mov  word[r_Table-019],'99'										; 2 Byte picture

		;	Record Address
		;	--------------
			mov @recordAddress(r_Table),r_Record							; Get Record Address				

		;	Get BSS memory and set table size
		;	---------------------------------
			mov @fieldLength(r_Table),r11									; Store table size
			
		$pushAll r9,r10,r11													; Save Regs			
			$w_getmem r11													; Allocate memory
		$popAll r11,r10,r9													; Restore Regs			
	
			push qword[w_TopOfBSS]											; Store start address													
			pop  qword[r_Table]
			push qword[w_BottomOfBSS]										; Store end address													
			pop  qword[r_Table-8]
			
_XBIND_EXIT:
			ret

;=======================================================================
;      		(SHELL SORT)
;=======================================================================
;-----------------------------------------------------------------------
; 	UBOUND				 STATUS 				 Table Indicator									 
;	+---+---+---+---+---+---+---+---+---+---+---------------+---+---------+------+	     
;	| 1	|'9'|Len|Val|Pic| 1	|'9'|Len|Val|Pic|Record Address	|'T'|NoOfBytes| NAME |
;	+---+---+---+---+---+---+---+---+---+---+---------------+---+---------+------+
;	-61					-27					-17				-9	-8			0	  
;-----------------------------------------------------------------------
;				   R8	R9		  R10	R11	 
;			TABLES sort,WorkTable,Start,End
;-----------------------------------------------------------------------
;	%idefine $address 	0
;	%idefine $index		1
;
;%imacro $getAddress 3
;	;	$getAddress RSI,r_Upper,$index/$address
;
;			mov %1,qword[r_Table]					; Start of Table to RSI/RDI
;			mov rax,%2								; Lower/Upper to RAX
;			dec rax									;	less 1
;			mul r_recordLength						; Multiply by Record Length	
;			
;	%%loop:	add %1,rax								; add offset to RSI/RDI
;	
;	%%If:	cmp qword[%1],0							; If Index is zero
;				ja %%EndIf							;	then
;			mov qword[%1],%1						;	set index as address
;	%%EndIf:			
;				
;		%if %3 = 1
;			mov %1,qword[%1]						; Copy the index
;		%endif
;		
;%endmacro
;
;%imacro $calcSpan 0
;			mov rax,r_Span							; Grab the span
;
;		;	----------------------------------------
;		;	SPECIAL CARE FOR THE BOTTOM OF THE TABLE
;		;	----------------------------------------
;		;	This fixes a bug I found in V1.14a
;	%%If:	cmp rax,2								; If we have NOT just processed slot 2
;			ja %%Else								; then jump to else
;			mov r_Span,qword[r_Table]				; ELSE setup exit for test coming out of this macro 
;			jmp %%Exit								; and exit
;	%%Else: cmp rax,3								; If we have NOT just processed slot 3
;				ja %%EndIf							; then jump to end if
;				mov rax,2							; ELSE setup the last slot manually
;				jmp %%Addr							; and proceed to get the address
;	%%EndIf:
;	
;			imul rax,10								; Scale it up by 10
;			cqo										; sign extend
;			idiv qword[dq_divisor]					; Divide 13 (1.3 unscaled)
;			
;	%%Addr:	mov qword[dq_SpanAsANumber],rax			; and store it
;			$getAddress r_Span,rax,$address
;			
;	%%Exit:
;%endmacro
;
;_XSORT:
;	;	Passed parameters
;	;			r_Table			r9	
;		%define r_startPos		r10				
;		%define r_noOfBytes		r11	
;		%define r_Divisor		r12		
;	;	Used in this routine
;		%define r_recordLength	r8
;		%define r_Lower			r10
;		%define r_Upper			r11
;		%define r_Swapped		r12
;		%define	r_Empty			r13
;		%define r_Span			r14
;		%define r_Ubound		r15
;
;	[section .data]		
;		dq_divisor				dq 18	; 1.3 scaled to 13 for integer maths
;		dq_startPos				dq 0	
;		dq_noOfBytes			dq 0	
;		dq_gap					dq 0
;		dq_SpanAsANumber		dq 0
;	[section .text]
;
;		;	(DO THIS 1ST SO r10,r11 are available Get start offset and No Of Bytes 
;			mov qword[dq_noOfBytes],r_noOfBytes							; and save it
;			dec r_startPos												; decrement the offset by 1
;			mov qword[dq_startPos],r_startPos							; and save it
;
;		;	Validate Divisor											
;			cmp r_Divisor,10											; Check Divisor
;			cmovb r_Divisor,qword[dq_divisor]							; reset if below
;			cmp r_Divisor,19											; Check Divisor
;			cmova r_Divisor,qword[dq_divisor]							; reset if above
;			mov qword[dq_divisor],r_Divisor								; save divisor				
;						
;		;	Get Record Length
;			mov r_recordLength,@recordAddress(r_Table)					; Get Record Address
;			mov r_recordLength,@fieldLength(r_recordLength)				; Get record Length	
;			add r_recordLength,9										; LiveFlag+Index
;
;		;	Get upper boundary
;			mov r10,@tableUbound(r_Table)								; Save Uboundary
;			$getAddress r_Ubound,r10,$address
;			
;		;	Setup the span										
;			mov r_Span,r10												; start with upper boundary	
;			$calcSpan
;		
;		;	------------------------------------------------------------
;		;	LOOP 1 Manages the span until it hit the bottom of the table					
;		;	------------------------------------------------------------
;	.Loop1: cmp r_Span,qword[r_Table]									; Loop until span hit bottom of table
;				je .Exit
;			
;			mov qword[dq_gap],r_Span									; get the gap
;			mov rax,qword[r_Table]
;			sub qword[dq_gap],rax			
;		
;		;	We will run from the calculated upper to the top of the table	
;			mov r_Upper,r_Span
;			sub r_Upper,r_recordLength
;			
;		;	-------------------------------------------------
;		;	LOOP 2 Runs from the span to the top of the table
;		;	-------------------------------------------------
;	.Loop2:	add r_Upper,r_recordLength
;			cmp r_Upper,r_Ubound
;				ja .EndLoop2
;
;		;	Start indexes at upper value
;			mov r_Lower,r_Upper											; Start lower at upper
;			sub r_Lower,qword[dq_gap]									;	less the gap	
;			xor r_Swapped,r_Swapped										; Set swap flag to false
;
;		;	Save upper sort key
;	.1If:	cmp qword[r_Upper],0										; If Index is zero
;				ja .1EndIf												;	then
;			mov qword[r_Upper],r_Upper									;	set index as address
;	.1EndIf:				
;			mov RSI,[r_Upper]
;
;			mov qword[w_RecordBuffer],RSI								; Store address
;			add RSI,9													; Jump over Key/Flag
;			add RSI,qword[dq_startPos]									;	+ start position
;			
;			mov RDI,w_RecordBuffer+9									; Save in w_RecordBuffer (Convenient)
;			mov rcx,qword[dq_noOfBytes]									; No Of Bytes
;		.l1:movsb
;			loop .l1
;
;			mov r_Empty,r_Upper											; Save empty slot
;			
;		;	--------------------------------------------------------
;		;	LOOP 3 Checks backwards (by the gap) when one is swapped
;		;	--------------------------------------------------------
;	.Loop3: cmp r_Lower,qword[r_Table]									; until bottom of table
;				jl .EndLoop3
;			
;	.2If:	cmp qword[r_Lower],0										; If Index is zero
;				ja .2EndIf												;	then
;	;	V2.03 - One of those "How the hell did it ever work in the 1st place" moments					
;	;		mov qword[r_Lower],r_Upper									;	set index as address
;			mov qword[r_Lower],r_Lower	
;	;	V2.03 - One of those "How the hell did it ever work in the 1st place" moments	
;	.2EndIf:				
;			mov RSI,[r_Lower]
;			
;			add RSI,9													; Jump over Key/Flag
;			add RSI,qword[dq_startPos]									;	+ start position
;
;			mov RDI,w_RecordBuffer+9									; get saved
;			mov rcx,qword[dq_noOfBytes]									; No Of Bytes
;		
;		;	Is the Lower > Saved (Upper)
;		.l2:cmpsb
;			ja .swap													; So swap them
;			jb .EndLoop3												; No swap required
;			loop .l2
;			
;			jmp .EndLoop3												; They are equal
;						
;		;	Write the lower to the upper
;	.swap:	mov r_Swapped,c_TRUE
;
;			mov RSI,r_Lower												; Get Lower
;			mov RDI,r_Empty												; Get Empty
;			push qword[RSI]												; move in lower indexes
;			pop	 qword[RDI]										
;			
;			mov r_Empty,r_Lower											; save new empty slot
;			sub r_Lower,qword[dq_gap]									; and drop lower by the gap 
;
;			jmp .Loop3
;	
;		;	-----------------------------------
;	.EndLoop3:	;	END LOOP 3
;		;	------------------------------------	
;			
;		;	Have we done a swap
;			cmp r_Swapped,c_TRUE
;				jne .Loop2
;				
;		;	Write the saved to the empty slot
;			mov RSI,w_RecordBuffer										; Get saved address
;			mov RSI,[RSI]
;			
;			mov RDI,r_Empty												; Get the empty slot
;			mov qword[RDI],RSI											; move in upper index
;		
;			jmp .Loop2
;		;	-------------------------------------	
;	.EndLoop2:	;	END LOOP 2		
;		;	-------------------------------------
;			mov r_Span,qword[dq_SpanAsANumber]
;			$calcSpan													; Get the new span
;			jmp .Loop1													; and loop
;		;	-------------------------------------	
;	.EndLoop1:	;	END LOOP 3
;		;	--------------------------------------
;
;	.Exit:
;_XSORT_EXIT:
;			ret

;-----------------------------------------------------------------------
;      		(QUICK SORT)
;-----------------------------------------------------------------------
;	******** REPLACES SHELL SORT **********
;-----------------------------------------------------------------------

	%imacro $getAddress 2
		mov %1,qword[r_Table]											; Start of Table to RSI/RDI
		mov rax,%2														; Lower/Upper to RAX
		mul r_recordLength												; Multiply by Record Length
		add %1,rax														; add offset to RSI/RDI
	
		mov rax,%1														; save the real address
	
	%%If:cmp qword[%1],0												; If Index is zero
			ja %%EndIf													;	then
		mov qword[%1],%1												;	set index as address
	%%EndIf:				
		
		mov %1,qword[%1]												; and use the index
	%endmacro

	%define r_recordLength	r8
	%define r_startPos		r10				
	%define r_noOfBytes		r11
	%define r_Ubound		r15
	
	%define @left 			r10
	%define @right 			r11
	%define @pivotValue		r12
	%define @prevLeft 		r13
	
	[section .bss]
		d_startPos			resq 1
		d_noOfBytes			resq 1
;		pivotValue			resb 128									; This gives tha max sortkey size
	[section .text]

	
_QUICKSORT:

;	DO THIS 1ST so r10,r11 are available Get start offset and No Of Bytes 
	mov qword[d_noOfBytes],r_noOfBytes									; and save it
	dec r_startPos														; decrement the offset by 1
	mov qword[d_startPos],r_startPos									; and save it

;	Get Record Length
	mov r_recordLength,@recordAddress(r_Table)					; Get Record Address
	mov r_recordLength,@fieldLength(r_recordLength)				; Get record Length	
	add r_recordLength,9				
			
;	Get upper boundary	
	mov rax,@tableUbound(r_Table)										; Get UBound index
	dec rax																;	less 1

;	Recursive Call
	push 0																; Push the 1st Left
	push rax															; Push the 1st Right (UBound)
	Call _QSort
	pop rax
	pop rax

_QUICKSORT_EXIT:
	ret
	

_QSort:

	mov @left,qword[rsp+16]												; get the Left Index
	mov @right,qword[rsp+8]												; get the Right Index
	
;	if  left >= right													; Exit when Left is not < Right
	cmp @left,@right
		jnl .Exit

;	pivotValue = RandomNo[ [ left + right / 2 ] ]						; CALCULATE pivotValue
	mov rax,@left														; Grab the left
	add rax,@right														; add the right
	shr rax,1															; and divide by 2
	$getAddress RSI,rax													; get the address of this slot
	add RSI,9															; and jump over index
	add RSI,qword[d_startPos]											; add the requested starting position
	mov @pivotValue,RSI	
	
;	prevLeftIdx = [moveThem]
	push @left															; preserve the Left index
	push @right															; preserve the Right index
	call _moveThem														; do the moves
	pop @right															; restore the Right index
	pop @left															; restore the Left index														
	mov @prevLeft,rax													; and save the returned value
	
;	-------------------------------------
;	Recursive Call - (left, prevLeft - 1)
;	-------------------------------------
	push @left															; preserve the Left index
	push @right															; preserve the Right index
	push @left															; push the 1st parameter (Left)
	mov rax,@prevLeft													; get the previous left
	dec rax																; minus 1
	push rax															; push the 2nd parameter
	Call _QSort															; Call yourself 	
	pop rax																; Junk this
	pop rax																; Junk this
	pop @right															; restore the Right index
	pop @left															; restore the Left index
	
;	----------------------------------
;	Recursive Call - (prevLeft, right)	
;	----------------------------------
	push @left															; preserve the Left index
	push @right															; preserve the Right index
	push @prevLeft														; push the 1st parameter (previous left
	push @right															; push the 2nd parameter (Right0
	Call _QSort															; Call yourself
	pop rax																; Junk this
	pop rax																; Junk this
	pop @right															; restore the Right index
	pop @left															; restore the Left index
	
	.Exit:
_QSort_EXIT:
	ret
	
_moveThem:

;	repeat.while (left <= right)
	cmp @left,@right													; Compare Left to Right Index
		jg .Exit														; exit if Left is > Right

;	repeat.while (Key[left] < pivotValue)
;			left 	= left + 1
;	end.repeat
	.start1:$getAddress RSI,@left										; Get the Start of the record 
			add RSI,9													; and jump over index
			add RSI,qword[d_startPos]									; add the requested starting position
			mov RDI,@pivotValue
			mov rcx,qword[d_noOfBytes]									; Grab the length (LOOP Ctr)
		Call _CMPSTR
			jnl .cont1													; If result not < than exit While Loop											
			inc @left													; get the next table slot			
			jmp .start1													; and repeat
	.cont1:

;	repeat.while (left <= right)
	cmp @left,@right													; Compare Left to Right Index
		jg .Exit														; exit if Left is > Right
		
;	repeat.while (Key[right]> pivotValue)
;		right 	= right - 1
;	end.repeat
	.start2:$getAddress RSI,@right										; Get the Start of the record
			add RSI,9													; and jump over index
			add RSI,qword[d_startPos]									; add the requested starting position
			mov RDI,@pivotValue	
			mov rcx,qword[d_noOfBytes]									; Grab the length (LOOP Ctr)
		Call _CMPSTR
			jng .cont2													; If result not > than exit While Loop	
			dec @right													; get the previous table slot
			jmp .start2													; and repeat
	.cont2:
	
	cmp @left,@right													; Compare Left to Right Index
		jg .Exit														; exit if Left is > Right
		jl .DoTheMove													; Do the move if less than
	
	;	No need to do the move if left = right
		inc @left														; increment the left 
		jmp .Exit														; and head for the exit
		

;	if left <= right - SWAP left and right data
.DoTheMove:	
	$getAddress RSI,@left												; RSI will contain the INDEX
	mov r14,rax															; RAX will contain the REAL address
	$getAddress RDI,@right												; RDI will contain the INDEX
	mov r15,rax															; RAX will contain the REAL address
	mov [r15],RSI														; Swap the indexes
	mov [r14],RDI														; 
	
	inc @left															; Next Left
	dec @right															; Previous Right
	jmp _moveThem														; Back to the Start
		
.Exit:	
	mov rax,@left														; Return the Left value

_moveThem_EXIT:
	ret

;=======================================================================
;      		SEARCH
;=======================================================================
;-----------------------------------------------------------------------
; 	UBOUND				 STATUS 				 Table Indicator									 
;	+---+---+---+---+---+---+---+---+---+---+---------------+---+---------+------+	     
;	| 1	|'9'|Len|Val|Pic| 1	|'9'|Len|Val|Pic|Record Address	|'T'|NoOfBytes| NAME |
;	+---+---+---+---+---+---+---+---+---+---+---------------+---+---------+------+
;	-61					-27					-17				-9	-8			0	  
;-----------------------------------------------------------------------
;				   R8		R9		  R10	R11 R12		R13 
;			TABLES search,	WorkTable,Start,End,Field,	Index (Returned)
;-----------------------------------------------------------------------

;	AS Passed by macro call
;			r_Function			r8
;			r_Table				r9
;	Used here (and reused)
	%define r_StartKey			r10
	%define r_EndKey			r11
	%define r_KeyAddress		r12
	%define r_Index				r13
	
;	AS used in this routine
	%define r_recordLength		r8
	%define r_Pivot				r11
	%define r_LowestRecordNo	r14
	%define r_HighestRecordNo	r15

_XSEARCH:

	%define r_KeyLength			rbx
	
	[section .data]
		db_live	db 0
	[section .text]
	

		;	--------------------------------------------------------
		;	PROCESS
		;	--------------------------------------------------------
		;	Get the key length
			sub r_EndKey,r_StartKey										; Subtract the start key position from the end key position
			inc r_EndKey												; add 1
			mov r_KeyLength,r_EndKey									; and store it
		;	r11(r_EndKey) can now be reused
					
;			Get recordLength/HighestRecordNo/LowestRecordNo
			mov r_recordLength,@recordAddress(r_Table)					; Get Record Address
			mov r_recordLength,[r_recordLength-8]						; Get the record length
			add r_recordLength,9										; add key/flag
			mov r_HighestRecordNo,@tableUbound(r_Table) 				; Use upper boundary
			mov r_LowestRecordNo,1										; and set lowest to 1
			
		;	---------------------------------------------
		;	1st Pivot Point
		;	---------------------------------------------
			mov rax,r_HighestRecordNo									; Grab the Highest Record No
			dec rax														; less the lowest record no (1 in this case)	
			shr rax,1													; divide by 2	

			mov rcx,2													; setup lowest pivot point
			cmp rax,rcx													; and compare it
			cmovl rax,rcx												; if need be make 2 the lowest pivet point
			cmp rax,r_HighestRecordNo									; is > highest (if only 1 element in table)
			cmovg rax,r_HighestRecordNo									; if so set it to 1 
			mov r_Pivot,rax												; and store it

		;	----------------------------------------------
		;	Setup Address
		;	----------------------------------------------
	.Oloop:	Call _getAddress

		;	----------------------------------------------
		;	Compare
		;	----------------------------------------------
			Call _compare
			cmp rax,0
				jg .above
				jl .below
				je .FOUND
				
		;	---------------------------------------------
		;	ABOVE
		;	---------------------------------------------
	.above:	cmp r_Pivot,r_HighestRecordNo								; If we have just processed the highest Record
				je .NotFound											;	then we have not found it
			cmp r_Pivot,r_LowestRecordNo								; If we have just processed the lowest Record
				je .NotFound											;	then we have not found it
				
			mov r_LowestRecordNo,r_Pivot								; set lowest record to pivot point	
			mov rax,r_HighestRecordNo									; Grab the high end
			sub rax,r_Pivot												; subtract the pivot point
	.1If:	cmp rax,1													; If we are 1 away from the highest
				jne .1Else												;	we cant divide by 2 (or else we get 0) so
				inc r_Pivot												;	move pivot to highest no
				jmp .Oloop												;	jump to the outer loop
	.1Else:	shr rax,1													; bisect the two points (divide by 2)
			add r_Pivot,rax												; and add it to the pivet point
			jmp .Oloop													; jump to the outerloop
	.1EndIf:

		;	---------------------------------------------
		;	BELOW
		;	---------------------------------------------
	.below:	cmp r_Pivot,r_LowestRecordNo								; If we have just processed the lowest record
				je .NotFound											;	then we have not found it
			cmp r_Pivot,r_HighestRecordNo								; If we have just processed the highest Record
				je .NotFound											;	then we have not found it
				
			mov r_HighestRecordNo,r_Pivot								; set the highest record to the pivet point
			mov rax,r_Pivot												; Grab the high end
			sub rax,r_LowestRecordNo									; subtract the lowest record
	.2If:	cmp rax,1													; if we are 1 away from the lowest
				jne .2Else												;	we cant divide by (or else we get 0) so
				dec r_Pivot												;	move pivot to Lowest No
				jmp .Oloop												;	jump to outer loop
	.2Else:	shr rax,1													; bisect the two points (divide by 2)
			sub r_Pivot,rax												; and subtract it from the pivet point				
			jmp .Oloop													; jump to outer loop
	.2EndIf:

		;	----------------------------
		;	NOT FOUND
		;	---------------------------
	.NotFound:
			mov @tableStatus(r_Table),23								; Set status to INVALIDKEY
			mov qword[r_Index],0										; and index to zero
			jmp .Exit													; and your out

		;	=============================	
		;	FOUND
		;	=============================
		;	If the key has been found then we need to look for duplicates.
		;	This is the same for both Live and Deleted records

	.FOUND:
			mov al,byte[RDI+8]											; Store the Live/Deleted byte
			mov byte[db_live],al
			mov qword[r_Index],r_Pivot									; set up the current index	
			
			call _XDUPLICATES											; find first occurence (if duplicates)		
	.3If:	cmp qword[foundIdx],0x00
				je .3EndIf
				push qword[foundIdx]
				pop  qword[r_Index]
	.3EndIf:
			
		;	get record - _TO_RECORD uses rax for record offset
			mov RDI,r_Table												; table address to rbx
			mov RDI,[RDI]												;	"	"	"	"	"		
			mov rax,qword[r_Index]										; Grab the Index
			mul r_recordLength											; times the record length
			sub rax,r_recordLength										;	less 1 record
			add RDI,rax			
	.4If:	cmp qword[RDI],0											; Does it have an index
				je .4EndIf												; NO - then skip
			mov RDI,[RDI]												; Else grab the index	
	.4EndIf:

			mov @tableStatus(r_Table),00								; Set status to OKAY	
			mov rax,RDI													; Store in rax for _TO_RECORD		
			call _TO_RECORD												
											
	.Exit:
_XSEARCH_EXIT:
			ret

;-----------------------------------------------------------------------
;			Called from SEARCH
;-----------------------------------------------------------------------
_XDUPLICATES:

	[section .bss]
		originalPivot	resq 1
		foundIdx		resq 1
	[section .text]

			mov qword[originalPivot],r_Pivot							; Save original pivot point
			mov qword[foundIdx],0x00									; and initialise found Index
			
			cmp r_Pivot,1												; Dont go below the start of the table
				je .FOLLOWING
					
			dec r_Pivot													; Look in previous slot 
			Call _getAddress
			
	.1loop:
			Call _compare
			cmp rax,0
				jg .FOLLOWING
				je .FOUND1
			
		;	-----------------------------
		;	FOUND
		;	-----------------------------
	.FOUND1:
	.1If:	mov RDI,[RDI]												; Get Address
			cmp byte[RDI+8],0x00										; If the found record is live
				je .1EndIf												;	
				inc byte[db_live]										; Use as record counter
				mov qword[foundIdx],r_Pivot								; Save our index			
			.2If:cmp byte[db_live],2									; Have we found more than 1 
					jl .2EndIf											; then set status as DUPLICATE
					mov @tableStatus(r_Table),22
			.2EndIf:
	.1EndIf:
	
			dec r_Pivot													; Now look for the 1st occurence
			cmp r_Pivot,1												; Dont go below the start of the table
				jl .FOLLOWING
			Call _getAddress
			
			jmp .1loop													; Find 1st duplicate

		;	===================================
		;	NONE BEFORE BUT MAYBE ONE FOLLOWING
		;	===================================
	.FOLLOWING:
	
	.4If:	cmp @tableStatus(r_Table),22								; If we have found the 1st one
				jne .4EndIf												;	set pivot to the first live record	
			mov r_Pivot,qword[foundIdx]									; 	and get the hell out
			jmp .Exit
	.4EndIf:

			mov r_Pivot,qword[originalPivot]							; restore Pivot point
			cmp r_Pivot,r_HighestRecordNo								; End Of Table	
				je .Exit												;	then exit
			inc r_Pivot													; Look in the next slot
			Call _getAddress
			
	.2loop:		
			Call _compare
			cmp rax,0			
				jl .Exit
				je .FOUND2

		;	-----------------------------
		;	FOUND
		;	-----------------------------
	.FOUND2:
	.5If:	mov RDI,[RDI]												; Get Address
			cmp byte[RDI+8],0x00										; If the found record is live
				je .5EndIf												;	save the Index
			.6If:cmp byte[db_live],0									; Have we found any before
					jg .6EndIf											; If NOT then
					mov qword[foundIdx],r_Pivot							; 	Save our index					
			.6EndIf:		
				inc byte[db_live]										; Use as record counter	
			.7If:cmp byte[db_live],2									; Have we found more than 1 
					jl .7EndIf											; then set status as DUPLICATE
					mov @tableStatus(r_Table),22
					jmp .Exit
			.7EndIf:
			
	.5EndIf:

			inc r_Pivot													; Now look for the next occurence
			cmp r_Pivot,r_HighestRecordNo								; Dont run off the end of the table
				je .Exit	
			Call _getAddress
			
			jmp .2loop
			
	.Exit:
_XDUPLICATES_EXIT:
			ret

;-----------------------------------------------------
;			common routine for _SEARCH and _DUPLICATES
;-----------------------------------------------------
;-----------------------------------------------------
;			Set up RDI from r_Pivot
;-----------------------------------------------------
_getAddress:			
			mov RDI,r_Table												; table address to RDI
			mov RDI,[RDI]												;	"	"	"	"	"
			mov rax,r_Pivot												; Grab the Pivot point
			dec rax														; and look for the previous one
			mul r_recordLength											; times the record length
			add RDI,rax													; add that to RDI
_getAddress_Exit:
			ret
			
;-----------------------------------------------------
;			receives RSI as searched for item
;			receives RDI as start of element
;			returns RAX
;-----------------------------------------------------
_compare:

			push RDI													; save slot address
			
		;	-------------------------------------------
		;	SETUP ADDRESS's
		;	-------------------------------------------
			mov RSI,r_KeyAddress										; RBX:key address to RSI
			
	.1If:	cmp qword[RDI],0											; Does it have an index
				je .1EndIf												; NO - then skip
			mov RDI,[RDI]												; Else grab the index			
	.1EndIf:
			add RDI,9													; add key/flag	
			add RDI,r_StartKey											; add the start key
			dec RDI														;	less 1
			
		;	-------------------------------------------
		;	COMPARE LOOP
		;	-------------------------------------------
			mov rcx,r_KeyLength											; RBX:loop thru the length of the key
			xor rdx,rdx 												; Use rdx to move to each byte
	.1loop:	mov  al,byte[RSI+rdx]										; grab the key
			cmp  al,byte[RDI+rdx]										; compare to table
				jg .above												; jump above
				jl .below												; jump below

			dec rcx														; drop the byte counter
			cmp rcx,0													; if we have 0 then
				je .equal												;	we have found a match
			inc rdx														; ELSE	move along one byte
			jmp .1loop													; and loop

		;	-------------------------------------------
		;	SET RESULTS FLAG (RAX)
		;	-------------------------------------------
	.equal:	xor rax,rax
			jmp .Exit
		
	.above:	mov rax,1
			jmp .Exit
	
	.below:	mov rax,-1
			jmp .Exit
			
	.Exit:
			pop RDI														; restore slot address
_compare_exit:
			ret
			
;=======================================================================
;      		Load Table from file
;=======================================================================
;-----------------------------------------------------------------------
; 	UBOUND				 STATUS 				 Table Indicator									 
;	+---+---+---+---+---+---+---+---+---+---+---------------+---+---------+------+	     
;	| 1	|'9'|Len|Val|Pic| 1	|'9'|Len|Val|Pic|Record Address	|'T'|NoOfBytes| NAME |
;	+---+---+---+---+---+---+---+---+---+---+---------------+---+---------+------+
;	-61					-27					-17				-9	-8			0	  
;
;-----------------------------------------------------------------------
;				   	R8		R9		  R10		R11
;			XTABLES load,	WorkTable,File,		IncludeDeletedRecs
;-----------------------------------------------------------------------

%imacro $readFile 3

		$pushAll r9,r10,r11
		
  		mov rbx,rsp															; Grab the stack pointer
  		and rsp,0xFFFFFFFFFFFFFFF0											; Align it to 16bytes
			push 0x00														; Overlapped ??
		sub RSP,32															; Create Shadow Stack
		cld																	; Clear Direction Flag
			mov rcx,%1								; @fileHandle(r_File)	; Set File Handle
			mov rdx,%2								; qword[r_Table]/RSI	; Buffer to read into
		   	mov r8,%3 								; qword[r_File-104]		; Bytes to read													; 
			mov r9,byteCount												; Returns Bytes read
			Call ReadFile
		mov rsp,rbx
    	$popAll r11,r10,r9
    	;	-----
    	;	ERROR
    	;	-----
    		cmp rax,-1														; If no error
  				jne %%Exit													;	then continue
  				Call GetLastError											; ELSE Get Error Code
  				mov qword[WIN_ReturnCode],rax								;	move it in
  				Call _SYSERROR												;	and terminate

  	%%Exit:			

%endmacro

_XLOAD:

	%define r_File					r10
	%define r_TableOffset			r12
	%define r_RecLength				r13
	%define r_Ubound				r14
	%define r_Offset				r15
	
		;	----------
		;	Initialise
		;	----------
			mov qword[dq_IncludeDeletedRecords],r11							; cuz it gets trashed ??
			mov @tableStatus(r_Table),0										; Set Table Status to zero
			xor	r_Ubound,r_Ubound											; Reset Upper Boundary
			mov r_TableOffset,[r_Table]										; Save the table offset
						
		;	---------
		;	Open File
		;	---------
		$pushAll r9,r10,r11
  		mov rbx,rsp															; Grab the stack pointer
  		and rsp,0xFFFFFFFFFFFFFFF0											; Align it to 16bytes
			push 0															; Null
			push 80															; File Attribute Normal
			push 3															; Open Existing
		sub RSP,32															; Create Shadow Stack
		cld																	; Clear Direction Flag
			mov rcx,r_File													; File Name
			mov rdx,0x80000000												; Gneric read
			mov r8,1														; Share Mode Read
			xor r9,r9														; Null
  			Call CreateFileA
  		mov rsp,rbx
		$popAll r11,r10,r9
		;	-----
		;	ERROR
		;	-----
  	.err1:	cmp rax,-1														; If no error
  				jne .NOerr1													;	then continue
  				Call GetLastError											; ELSE Get Error Code
  				mov qword[WIN_ReturnCode],rax								;	move it in
  				Call _SYSERROR												;	and terminate
  	.NOerr1:mov @fileHandle(r_File),rax										; Store file handle
			mov rdi,@fileHandle(r_File)										; Set File Handle	
			
		;	==================================
		;	SWALLOW AN INDEXED FILE IN ONE HIT
		;	==================================
			cmp @fileDelimiter(r_File),c_INDEXED								; Are we indexed
				jne .Random

  			$readFile @fileHandle(r_File),qword[r_Table],qword[r_File-104]

		;	------------------
		;	POPULATE THE INDEX
		;	------------------ 	
			mov rbx,@recordAddress(r_Table)									; Get record address
			mov rbx,@fieldLength(rbx)										; then length of record
			add rbx,9														; + Index/Flag
			mov rax,qword[r_File-104]										; file size to rax
			cqo																; ready to divide
			div rbx															; divided by record length
			mov @tableUbound(r_Table),rax									; to give upper boundary

			mov RSI,[r_Table]												; Now copy each address to its index
			mov rcx,rax
		.l: mov [RSI],RSI
			add RSI,rbx
			loop .l

		;	------
		;	& DONE
		;	------
			jmp .close
			
			
		;	===================
		;	RANDOM ACCESS FILES
		;	===================	
	.Random:mov r_RecLength,@recordAddress(r_Table)							; Get record address
			mov r_RecLength,@fieldLength(r_RecLength)						; then length of record
			inc r_RecLength													; + live/deleted flag
			mov r_Offset,r_RecLength										; Grab Record Length
			add r_Offset,8													; + Index
			mov rsi,r_TableOffset											; Address of start of table
			sub rsi,r_Offset												; prepare for add at top of loop
			add rsi,8														; position after index
			
		;	--------------------
		;	LOOP	
		;	--------------------
	.loop:	add RSI,r_Offset
			$readFile @fileHandle(r_File),RSI,r_RecLength
  	
    		cmp dword[byteCount],0											; End Of File
    			je .Eloop
	
			inc r_Ubound													; Increment the UBound				
			mov qword[RSI-8],RSI											; Store the Index
			sub qword[RSI-8],8

		;	---------------
		;	DELETED RECORDS
		;	---------------				
			cmp byte[RSI],0x01												; Loop for Live records
				je .loop
	.temp:	cmp qword[dq_IncludeDeletedRecords],c_TRUE						; Do we want deleted records
				je .loop													;	then skip
				
			sub RSI,r_Offset												; Overwrite deleted record
			dec r_Ubound													; Decrement the UBound
			jmp .loop														; and loop		
			
	.Eloop:			
		;	--------------------
		;	END LOOP	
		;	--------------------
			mov	@tableUbound(r_Table),r_Ubound								; Store the upper boundary

		;	---------			
		;	and close
		;	---------
	.close:	mov rcx,@fileHandle(r_File)										; Set File Handle	
  		mov rbx,rsp															; Grab the stack pointer
  		and rsp,0xFFFFFFFFFFFFFFF0											; Align it to 16bytes
		sub RSP,32															; Create Shadow Stack
		cld																	; Clear Direction Flag
			Call CloseHandle
		mov rsp,rbx
		
	.Exit:
_XLOAD_EXIT:
			ret

;=======================================================================
;      		UnLoad Table to file
;=======================================================================
;-----------------------------------------------------------------------
; 	UBOUND				 STATUS 				 Table Indicator									 
;	+---+---+---+---+---+---+---+---+---+---+---------------+---+---------+------+	     
;	| 1	|'9'|Len|Val|Pic| 1	|'9'|Len|Val|Pic|Record Address	|'T'|NoOfBytes| NAME |
;	+---+---+---+---+---+---+---+---+---+---+---------------+---+---------+------+
;	-61					-27					-17				-9	-8			0	  
;
;-----------------------------------------------------------------------
;				   	R8		R9		  R10		R11
;			XTABLES unload,	WorkTable,File,		IncludeDeletedRecs
;-----------------------------------------------------------------------
_XUNLOAD:

;	Passed into this routine - but eaten by syscall
	%define r_File					r10		; Redefine cuz it gets redefined above
	%define r_LiveFlagOffset		r11

	%define r_TableOffset			r12
	%define r_RecLength				r13
	%define r_Ubound				r14
	
		;	----------
		;	Initialise
		;	----------
			mov qword[dq_IncludeDeletedRecords],r11							; cuz it gets trashed ??

		;	Table Offset and Record length
			mov r_TableOffset,[r_Table]										; Table address
			mov r_RecLength,@recordAddress(r_Table)							; Get record address
			mov r_RecLength,@fieldLength(r_RecLength)						; then length of record
			inc r_RecLength													; + live/deleted flag
	.1If:	cmp @fileDelimiter(r_File),c_INDEXED							; Are we indexed			
				jne .1EndIf
			add r_RecLength,8
	.1EndIf:
	
		;	Upper Boundary
			mov r_Ubound,@tableUbound(r_Table)			

		;	---------
		;	Open File
		;	---------
		$pushAll r9,r10,r11
  		mov rbx,rsp															; Grab the stack pointer
  		and rsp,0xFFFFFFFFFFFFFFF0											; Align it to 16bytes
			push 0															; Null
			push 80															; File Attribute Normal
			push 2															; Create Always
		sub RSP,32															; Create Shadow Stack
		cld																	; Clear Direction Flag
			mov rcx,r_File													; File Name
			mov rdx,0x40000000												; Gneric write
			mov r8,2														; Share Mode Write
			xor r9,r9														; Null
  			Call CreateFileA
  		mov rsp,rbx
		$popAll r11,r10,r9
		
  	.0If:	cmp rax,-1
  				jne .0EndIf	
  				Call GetLastError
  				mov qword[WIN_ReturnCode],rax
  				Call _SYSERROR
  	.0EndIf:
  	
 			mov @fileHandle(r_File),rax										; and save the file handle		
		
		;	--------------------
		;	LOOP	
		;	--------------------			
			sub r_TableOffset,r_RecLength									; prepare for add at top of loop
			xor r15,r15
		
	.loop:	inc r15
			cmp r15,r_Ubound
				ja .Eloop
			add r_TableOffset,r_RecLength									; Calc the table offset
			mov RSI,r_TableOffset											; and setup RSI

		;	Normally grab the index but if it has not been moved in the sort
		;	it may still be zero
			xor r_LiveFlagOffset,r_LiveFlagOffset							; initialise 													; To store the index length
	.Case1:	cmp qword[RSI],0
				je .Case2
				mov RSI,[RSI]												; grab the TABLE Index
	.Case2:	cmp @fileDelimiter(r_File),c_INDEXED							; Is our file indexed
				jne .EndCase
				add r_LiveFlagOffset,8
	.EndCase:
	
		;	---------------
		;	DELETED RECORDS
		;	---------------				
	.3If:	cmp byte[RSI+r_LiveFlagOffset],0x01								; Write Live records
				je .3EndIf
	.3Else:	cmp qword[dq_IncludeDeletedRecords],c_FALSE						; Do we want deleted records
				je .loop													;	then skip
	.3EndIf:

		;	-----
		;	WRITE
		;	-----			
	.write:	
		$pushAll r9,r10,r11
  		mov rbx,rsp															; Grab the stack pointer
  		and rsp,0xFFFFFFFFFFFFFFF0											; Align it to 16bytes
			push 0x00														; Overlapped ??
		sub RSP,32															; Create Shadow Stack
		cld																	; Clear Direction Flag
			mov rcx,@fileHandle(r_File)										; Set File Handle
			mov rdx,RSI														; Address of record
			mov r8d,r13d													; This record length
			mov r9,byteCount												; Returns Bytes Written
			Call WriteFile
		mov rsp,rbx
		$popAll r11,r10,r9
		
	;	-----
	;	Error
	;	-----
  		cmp rax,0															; Windows returns 1 no error
  			ja .eof															; test for end
  			Call GetLastError
  			mov qword[WIN_ReturnCode],rax
  			Call _SYSERROR
			
   	.eof:cmp dword[byteCount],0												; End Of File
    		je .Eloop

    	jmp .loop															; so loop

		;	--------------------
		;	END LOOP	
		;	--------------------				
	.Eloop:	
	
		;	--------------------
		;	CLOSE
		;	--------------------				
	.close:	mov rcx,@fileHandle(r_File)										; Set File Handle	
  		mov rbx,rsp															; Grab the stack pointer
  		and rsp,0xFFFFFFFFFFFFFFF0											; Align it to 16bytes
		sub RSP,32															; Create Shadow Stack
		cld																	; Clear Direction Flag
			Call CloseHandle
		mov rsp,rbx

	.Exit:	pop r11
_XUNLOAD_EXIT:
			ret
			
;=======================================================================
;      		Calculate Offset from Indexes
;=======================================================================
;-----------------------------------------------------------------------
; 	UBOUND				 STATUS 				 Table Indicator									 
;	+---+---+---+---+---+---+---+---+---+---+---------------+---+---------+------+	     
;	| 1	|'9'|Len|Val|Pic| 1	|'9'|Len|Val|Pic|Record Address	|'T'|NoOfBytes| NAME |
;	+---+---+---+---+---+---+---+---+---+---+---------------+---+---------+------+
;	-61					-27					-17				-9	-8			0	  
;-----------------------------------------------------------------------
;RETURNS:	RAX = Offset
;-----------------------------------------------------------------------
	%define r_Index			r10
	%define r_RecLength		r11

_XOFFSET:

			push r10		; save what you change
			push r11		; save what you change

			mov @tableStatus(r_Table),0									; Set Table Status to zero

		;	End Of Table ????
	.0If:	mov rax,r_Index												; Grab the Record Number
			cmp rax,@tableUbound(r_Table)								; and compare to upper boundary
				jna .0EndIf												; jump if <=
	.0Else:	mov @tableStatus(r_Table),10								; Set Table Status to EOF
				jmp _XOFFSET_EXIT										; and exit
	.0EndIf:			
			
		;	grab the record length + 1 + 8
			mov r_RecLength,@recordAddress(r_Table)						; Get record address
			mov r_RecLength,@fieldLength(r_RecLength)					; then length of record
			add r_RecLength,9											; allow for index (Xtable Index)

			mov qword[saveRecLength],r_RecLength						; Save it. (Used in Delete)

		;	calculate the offset			
		;	mov rax,r_Index			ALREADY GOT IT ABOVE				; Grab the Record Number
			dec rax														; less 1 to give offset
			mul r_RecLength												; Multiply by the adjusted record length
			add rax,qword[r_Table]										; and add the table address

		;	Get the Index	
	.1If:	cmp qword[rax],0											; Do we have an index (Xtable Index)
				je .1EndIf												; NO then continue
			mov rax,[rax]												; YES move in the index
	.1EndIf:

	.2If:	cmp rax,qword[w_BottomOfBSS]								; Is it below its BSS limit
				jb .2EndIf												; 	we are out	
			mov @tableStatus(r_Table),23								; Set status to INVALIDKEY
	.2EndIf:		

_XOFFSET_EXIT:
			pop r11		; restore what you changed
			pop r10		; restore what you changed
			ret

;=======================================================================
;      		(DELETE) Fill TABLE entry with high-values
;=======================================================================
;-----------------------------------------------------------------------
; 	UBOUND				 STATUS 				 Table Indicator									 
;	+---+---+---+---+---+---+---+---+---+---+---------------+---+---------+------+	     
;	| 1	|'9'|Len|Val|Pic| 1	|'9'|Len|Val|Pic|Record Address	|'T'|NoOfBytes| NAME |
;	+---+---+---+---+---+---+---+---+---+---+---------------+---+---------+------+
;	-61					-27					-17				-9	-8			0	  
;-----------------------------------------------------------------------
;				   R8		R9			R10,	R11
;			TABLES delete, 	WorkTable,	Idx,	Initialise
;-----------------------------------------------------------------------
;			Receives RAX as record offset
;			Move ALL NULLS but leave the Index for SORT
;-----------------------------------------------------------------------
_DELETE:

			mov RSI,dq_Nulls
			lea RDI,[rax+8]
			mov byte[RDI],0x00											; Set the record to NOT Live
			cmp r11,c_TRUE												; Do we want to initialise it
				jne _DELETE_EXIT										; If not then jump
																		; else
			mov rcx,qword[saveRecLength]								;	fill it with Nulls
			sub rcx,8
			$copyQwords
			
_DELETE_EXIT:
			ret
			
;=======================================================================
;      		(rPUT) Move RECORD to TABLE
;=======================================================================
;-----------------------------------------------------------------------
; 	UBOUND				 STATUS 				 Table Indicator									 
;	+---+---+---+---+---+---+---+---+---+---+---------------+---+---------+------+	     
;	| 1	|'9'|Len|Val|Pic| 1	|'9'|Len|Val|Pic|Record Address	|'T'|NoOfBytes| NAME |
;	+---+---+---+---+---+---+---+---+---+---+---------------+---+---------+------+
;	-61					-27					-17				-9	-8			0	  
;-----------------------------------------------------------------------
;				   R8	R9			R10
;			TABLES get, WorkTable,	Idx
;-----------------------------------------------------------------------
;			Receives RAX as record offset
;-----------------------------------------------------------------------
_FROM_RECORD:

;	V2.05 we actually return the deleted record
;			If you write to a deleted record hen you are making it live
			mov byte[rax+8],0x01	
;	V2.05 we actually return the deleted record

			mov RSI,@recordAddress(r_Table)								; Get source (record address)

		;	Reset Upper Boundary ??			
	.1If:	mov rbx,@recordNo(RSI)										; Is the record no > upper boundary
			cmp rbx,@tableUbound(r_Table)
				jb .1EndIf												; If so then
				mov	@tableUbound(r_Table),rbx							; move in the new upper boundary
	.1EndIf:
					
			add RSI,17													; Go to start of word/number

			mov RDI,rax													; Grab the offset
			mov qword[RDI],rax											; save index
			add RDI,8													; Jump over index
			mov byte[RDI],0x01											; Set the record to LIVE
			inc RDI														; Jump over Live Flag
	
		;	START LOOP -------------------------------------------------
;			$fromRecord
		;	START LOOP -------------------------------------------------						
	.loop:	cmp @fieldIndicator(RSI),0x00								; Loop Here - ARE WE DONE
				je _FROM_RECORD_EXIT

			cmp @fieldIndicator(RSI),'9'								; If the field is a number then
				je .nos													;	Do Number

		;---WORDS ****	
			mov rcx,@fieldLength(RSI)									; Grab the length of the field
	.X:		movsb														; move the bytes
			loop .X														;
			add RSI,17													; Next Word
			jmp .loop													; and jump to end of field process
		;	END LOOP for Alpha -----------------------------------------
					
		;---NUMBERS ****	
		;	Convert the binary number to ascii (LEFT to RIGHT)
	.nos:	$pushAll r8,r9,r10,r11,r12,r13,r14,r15,rsi,rdi				; Save everything											
			mov r9,RSI													; Setup source (number)	
			xor r10,r10													; Clear picture override
			xor r11,r11													; Clear picture override
			mov r12,w_Temp												; Using w_Temp
			mov r13,[w_One]												; Start at 1
			mov r15,c_TRUE												; Tell _TOALPHA to Set length of Destination
			Call _TOALPHA												; Make the call
			$popAll rdi,rsi,r15,r14,r13,r12,r11,r10,r9,r8				; Restore everything

			PUSH RSI
			mov RSI,w_Temp												; Reset the source to w_Temp
			mov rcx,@fieldLength(w_Temp)								; Grab the length of the field
	.9:		movsb														; move the bytes
			loop .9									
			POP RSI
			
		;	Jump over stuff
			mov rax,RSI													; Address of Number
			add rax,8													; 	jump over no
			add rax,@fieldLength(RSI)									;	add length of picture
			add rax,17													;	add 17 (number)
			mov RSI,rax													; store the new offset
			jmp .loop
		;	END LOOP for Number ----------------------------------------

;
;	NOT A BAD IDEA TO LEAVE THIS FOR THE MOMENT FOR DEBUGGING
;	refer TABLES.LIB for that	


							
_FROM_RECORD_EXIT:
			ret

;=======================================================================
;      		(rGET) Move TABLE to record
;=======================================================================
;-----------------------------------------------------------------------
; 	UBOUND				 STATUS 				 Table Indicator									 
;	+---+---+---+---+---+---+---+---+---+---+---------------+---+---------+------+	     
;	| 1	|'9'|Len|Val|Pic| 1	|'9'|Len|Val|Pic|Record Address	|'T'|NoOfBytes| NAME |
;	+---+---+---+---+---+---+---+---+---+---+---------------+---+---------+------+
;	-61					-27					-17				-9	-8			0	  	
;-----------------------------------------------------------------------
;				   R8	R9			R10
;			TABLES get, WorkTable,	Idx
;-----------------------------------------------------------------------
;      		(GET) Move TABLE to RECORD
;-----------------------------------------------------------------------
;			Receives RAX as record offset
;-----------------------------------------------------------------------
_TO_RECORD:

;	V2.05 we actually return the deleted record
		;	INVALID KEY
	.1If:	cmp byte[rax+8],0x01										; Is the record ALIVE
				je .1EndIf
				mov @tableStatus(r_Table),23							; Set status to INVALIDKEY
	.1EndIf:	
;	V2.05 we actually return the deleted record
	
			lea RSI,[rax+9]												; Jump over the Index/Live Flag
			mov RDI,@recordAddress(r_Table)								; Get record address
			add RDI,17													; Go to start of word/number

		;	START LOOP -------------------------------------------------
			$toRecord

;	NOT A BAD IDEA TO LEAVE THIS FOR THE MOMENT FOR DEBUGGING
;	refer TABLES.LIB for that				
	
_TO_RECORD_EXIT:
			ret

;=======================================================================
;      		(fGET) Move TABLE FIELD to FIELD
;=======================================================================
;-----------------------------------------------------------------------
; 	UBOUND				 STATUS 				 			Table Indicator									 
;	+---+---+---+---+---+---+---+---+---+---+---------------+---+---------+------+	     
;	| 1	|'9'|Len|Val|Pic| 1	|'9'|Len|Val|Pic|Record Address	|'T'|NoOfBytes| NAME |
;	+---+---+---+---+---+---+---+---+---+---+---------------+---+---------+------+
;	-61					-27					-17				-9	-8			0	  
;-----------------------------------------------------------------------
;					R8		R9		  R11	  R12		   R10
;			XTABLES fget,	WorkTable,FieldNo,FieldAddress,Idx
;-----------------------------------------------------------------------
;			Receives RAX as record offset
;-----------------------------------------------------------------------
;
;	NOTE:-	_FGET and _FPUT (below) are near identical.
;			_FGET goes from table to field
;			_FPUT goes field to table
;	Almost just a case of swapping RSI/RDI (but not quite)

	%define r_FieldNo			r11
	%define r_FieldAddress		r12

_FGET:

;	V2.05 we actually return the deleted record
		;	INVALID KEY
			mov @tableStatus(r_Table),00								; Assume Live			
	.1If:	cmp byte[rax+8],0x01										; Is the record ALIVE
				je .1EndIf
				mov @tableStatus(r_Table),23							; Set status to INVALIDKEY
	.1EndIf:	
;	V2.05 we actually return the deleted record

		;	GRAB the START OF THE TABLE ROW		
			lea RSI,[rax+9]												; Jump over the Index/Live Flag

		;	GRAB the START of the RECORD
			mov RDI,@recordAddress(r_Table)								; Get record address

		;	NOW CYCLE THRU THE RECORD TO THE REQUIRED FIELD
			xor rdx,rdx													; Used to accumulate the offset
			mov rcx,r_FieldNo											; Field No 
			dec rcx														; less 1 
			cmp rcx,0													; Offset is 0
				je .move												;	then nothing to do

	.step:	add RDI,17													; Go to start of word/number
			add rdx,qword[RDI-8]										; And accumulate the size

			mov al,@fieldIndicator(RDI)									; Save the field Indicator
			add RDI,qword[RDI-8]										; add length of field				
			cmp al,'X'													; If alpha field
				je .both												;	small jump
			add RDI,8													; ELSE add 64 bit No itself 
	.both:	loop .step													; and loop

			add RSI,rdx													; add offset to table address
			
	;	------------------------
	;	EXTRACTED FROM $toRecord
	;	------------------------
	.move:	mov RDI,r_FieldAddress										; setup the field address
			cmp @fieldIndicator(RDI),'9'								; If the field is a number then
				je .nos													;	Do Number

		;---WORDS	
			mov rcx,@fieldLength(RDI)									; Grab the length of the field
	.X:		movsb														; move the bytes
			loop .X						
			jmp _FGET_EXIT 
							
		;---NUMBERS	
		;	Convert the ascii number to binary (RIGHT to LEFT)		
	.nos:	
		;	$pushAll r8,r9,r10,r11,r12,r13,r14,r15,rsi,rdi				; Save everything											
			mov r9,RDI													; Set destination (binary)
			xor r10,r10													; Clear picture override
			xor r11,r11													; Clear picture override
			mov r12,RSI													; Set source (alpha)
			mov r13,[w_One]												; start at 1
			mov r14,[r9-8]												; Length (destination length)
			Call _FROMALPHA												; Make the call
	;		$popAll rdi,rsi,r15,r14,r13,r12,r11,r10,r9,r8				; Restore everything
	;	------------------------
	;	EXTRACTED FROM $toRecord
	;	------------------------

_FGET_EXIT:
			ret

;=======================================================================
;      		(fPUT) Move FIELD to TABLE
;=======================================================================
;-----------------------------------------------------------------------
; 	UBOUND				 STATUS 				 			Table Indicator									 
;	+---+---+---+---+---+---+---+---+---+---+---------------+---+---------+------+	     
;	| 1	|'9'|Len|Val|Pic| 1	|'9'|Len|Val|Pic|Record Address	|'T'|NoOfBytes| NAME |
;	+---+---+---+---+---+---+---+---+---+---+---------------+---+---------+------+
;	-61					-27					-17				-9	-8			0	  
;-----------------------------------------------------------------------
;					R8		R9		  R11	  R12		R10
;			XTABLES fput,	WorkTable,FieldNo,Fieldname,Idx
;				R13/R14 (Picture Over-ride or qualified alpha)
;-----------------------------------------------------------------------
;			Receives RAX as record offset
;-----------------------------------------------------------------------
;
;	NOTE:-	_FPUT and _FGET (above) are near identical.
;			_FGET goes from table to field
;			_FPUT goes field to table
;	Almost just a case of swapping RSI/RDI (but not quite)

_FPUT:

;	For single field manipulation you gotta assume that live/deleted records
;	are not an issue (All will be live records??)
;	INVALID KEY
;	.1If:	cmp byte[rax+8],0x01										; Is the record ALIVE
;				je .1EndIf
;				mov @tableStatus(r_Table),23							; Set status to INVALIDKEY
;				jmp _FGET_EXIT
;	.1EndIf:
;	V2.03-------------------------------------------------------------------------------------
;	V2.03 - Above is not the whole story. a FPUT may be the 1st thing that happens to a record
;			so the live/deleted flag needs to be set

			mov byte[rax+8],0x01
			
;	V2.03-------------------------------------------------------------------------------------

		;	GRAB the START OF THE TABLE ROW		
			lea RDI,[rax+9]												; Jump over the Index/Live Flag

		;	GRAB the START of the RECORD
			mov RSI,@recordAddress(r_Table)								; Get record address

		;	NOW CYCLE THRU THE RECORD TO THE REQUIRED FIELD
			xor rdx,rdx													; Used to accumulate the offset
			mov rcx,r_FieldNo											; Field No 
			dec rcx														; less 1 
			cmp rcx,0													; Offset is 0
				je .move												;	then nothing to do

	.step:	add RSI,17													; Go to start of word/number
			add rdx,qword[RSI-8]										; And accumulate the size

			mov al,@fieldIndicator(RSI)									; Save the field Indicator
			add RSI,qword[RSI-8]										; add length of field				
			cmp al,'X'													; If alpha field
				je .both												;	small jump
			add RSI,8													; ELSE add 64 bit No itself 
	.both:	loop .step													; and loop

			add RDI,rdx													; add offset to table address
			
	;	--------------------------
	;	EXTRACTED FROM $fromRecord
	;	--------------------------
	;	It is a wee bit different because the record field does not 
	;	have to be used. For the put, a literal may be used, however
	;	you must use a picture over-ride because the default picture
	;	for a literal is 26 chars, probably bigger than associated
	;	record field.
 
	.move:	mov RSI,r_FieldAddress										; setup the field address
			cmp @fieldIndicator(RSI),'9'								; If the field is a number then
				je .nos													;	Do Number

		;---WORDS
			cmp r13,0													; If it Is not qualified
				je .X													;	then just do it
			add RSI,r13													; ELSE add the starting position
			dec RSI
	
			mov rcx,@fieldLength(RSI)									; Grab the length of the field
			cmp r14,0													; If it does not have a NoOfBytes
				je .X													;	then just do it
			mov rcx,r14													; ELSE over-write counter (rcx)		

	.X:		movsb														; move the bytes
			loop .X						
			jmp _FPUT_EXIT 
							
		;---NUMBERS	
		;	Convert the binary number to ascii (LEFT to RIGHT)		
	.nos:	
		;	$pushAll r8,r9,r10,r11,r12,r13,r14,r15,rsi,rdi				; Save everything
			push RDI											
			mov r9,RSI													; Setup source (number)	
			mov r10,r13													; picture override (Address)
			mov r11,r14													; picture override (Length)
			mov r12,w_Temp												; Using w_Temp
			mov r13,[w_One]												; Start at 1
			mov r15,c_TRUE												; Tell _TOALPHA to Set length of Destination
			Call _TOALPHA												; Make the call
		;	$popAll rdi,rsi,r15,r14,r13,r12,r11,r10,r9,r8				; Restore everything
			pop RDI

			mov RSI,w_Temp												; Reset the source to w_Temp
			mov rcx,@fieldLength(w_Temp)								; Grab the length of the field
	.9:		movsb														; move the bytes
			loop .9									
	;	------------------------
	;	EXTRACTED FROM $fromRecord
	;	------------------------

_FPUT_EXIT:
			ret

			
