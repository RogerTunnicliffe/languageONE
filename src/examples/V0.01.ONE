%include 'include/BEGIN.PROGRAM'

;	Refer to VERSION.HISTORY for...well...version history

;	BEGIN.SYNONYMS **************************************
;		$.	:	WORDS.  
;		@.	:	INTEGERS.  
;		#.	:	NUMBERS.  
;		f.	:	files. 
;		t.	:	tables.
;		T.	:	xtables. 
;	END.SYNONYMS ****************************************

;=======================================================================
;		  PROGRAM DATA
;=======================================================================	      
;	The 'dictionary' is the area of the program where words, phrases and
;	sentences may be described. 
;	The %include 'BEGIN.DICTIONARY' directive is used 
;		to inform the system that the dictionary will begin here. 
;	The %include 'END.DICTIONARY' directive is used
;		to inform the system that the Dictionary is complete
;
;	Each entry begins with the keyword  'insertword', followed by a name
;	you choose to refer to  the item within the program.  It is followed
;	by the length of the  word you are  describing and  finally the word
;	itself.  The name  you choose  is case  sensitive, that  is If  your
;	chosen name is AccountNo, then accountno will not be recognised.
;	 
;	Each entry following the insertword command is seperated by a comma.
;	If a word  (sentence) is  shorter than the described length then the
;	remainder of the word/sentence will be filled with space. 	If it is
;	longer that the described length then an error will be reported

;	The following words have been defined by the system
;		w_CommandLine	:  Contains the arguments entered at the command
;						   line
;		LF				:  LineFeed character. (Used with display)
;
;	Valid characters in word names are letters,_,$,#,@,and ?
;	The 1st character must be a letter, _, @, ?
;	You can prefix a languageONE 'keyword' with a $ If you wish to use it.

%include 'include/BEGIN.DICTIONARY'
 
	insertword	result,					08, 'NOT TRUE'
	insertword	inputLine,				80, ' '
	insertword 	char1,					01, ' '
	insertword	Fox,					43, 'The quick brown fox jumps over the lazy dog'
	insertword 	word1,    				26, 'abcdefghijklmnopqrstuvwxyz'        
	insertword	word2,   				26, '12345678901234567890123456'
	insertword 	outputLine, 			80, ' '
	insertword	numericBuffer,			16, ' '
	
	insertword	outerWord,				23, 'This is the outer word'
	insertword	middleWord,				23, 'This is the middle word'
	insertword	innerWord,				23, 'This is the inner word'

;	For Synonyms
	insertword	w_Synonym,				11,''
	
%include 'include/END.DICTIONARY'

;=======================================================================
;	The  'matrix'  is the  area of  the  program  where numbers  may be
;	described. 
;	The %include 'BEGIN.MATRIX' directive is used 
;		to inform the system that the Matrix will begin here. 
;	The %include 'END.MATRIX' directive is used
;		to inform the system that the Matrix is complete
;
;	Each entry begins with the keyword 'insertnumber',followed by a name
;	you choose to refer to  the item within the program.  It is followed
;	by the number  and  then (Optionally) by  a   'picture'.  Each entry
;	following the insertnumber command is seperated by a comma.
;
;	The numbers  'picture'  describes how the system handles/outputs the 
;	number.It comprises a series of characters that define the formating
;	of the number in a similar way to the BASIC programming language.
;	The following symbols are represented:-
;		'-' (the minus sign) [Last character]
;			This  defines the  number as  being  signed.  The number can
;			represent both positive and negative #.
;		'9' This defines a place value for the number.
;			If there is a zero in this position it will be displayed
;		'#' This also defines a place value for the number
;			However,a zero in this position will be displayed as a space
;		',' This  defines a thousands  indicator and will will displayed
;			when appropriate.
;		'.' This defines the number as a FixedPoint number. 
;
;	PLEASE NOTE:-  If an integer does not  have an  associated picture, a 
;	picture will developed by the system  according to the value  of the 
;	number.  ie If the no  is  set at  123 [#.EQ No,123] then  the
;	picture will be '999'.  Equally If a the number is accepted as input
;	language ONE will assign a picture developed from that input.
;	ie. accept=1,234.56- Assigned Picture= 9,999.99-
;
;	Valid characters in number names are letters,_,$,#,@,and ?
;	The 1st character must be a letter, _, @, ?
;	You can prefix a 'keyword' with a $ If you wish to use it.
;
;	INTEGERS
;		Unsigned: All numbers will be considered as signed
;		Signed:   From âˆ’9,223,372,036,854,775,808 to 9,223,372,036,854,775,807
;						can represented as integer
;
;	FIXED POINT #.
;		Fixed Point numbers are used in languageONE. This is dIfferent 
;		from many programming languages that use floating point number.
;		Floating point numbers require a FPU and are not entirely
;		accurate. (Ever had that experience with a calculator where you
;		enter something like 2 * 2 and get an answer of 3.9999999999
;		
;		Fixed point numbers in languageONE are integers with an 'implied' 
;		decimal place. This is implemented via the picture clause of the
;		insertnumber statement. By defining a picture like '999.99', you
;		are asking for a number that contains 2 decimal places.
;		A picture of say '#,###,##9.9999-' defines a number with decimal
;		places witha sign displayed (remembering all numbers are treated
;		as signed).    
;
;		Because all numbers are actually 64 bit integers the following
;		restrictions apply to Fixed Point numbers.
;		Placing an implied sign into a integer:-
;		 (9,223,372,036,854,775,807) the following range is encapsulated
;		  .9223372036854775807
;			This number can define the size of something smaller
;			than an electron
;		  922337203685477580.7	
;			This number can count, in seconds, from the big bank until
;			now and be only half filled. 
;		equally the largest number that contains the largest no of 
;		decimal places is 9223372036.854775807
;
;=======================================================================
%include 'include/BEGIN.MATRIX'

    ;   Common Counters
	insertnumber I,0,'999999'
	insertnumber J,0,'999999'
	insertnumber K,0,'999999'
	insertnumber L,0,'999999-'

;   Program specIfic	
	insertnumber Start,						5,'999'
	insertnumber NoOfCharacters,	   	   11,'999'
	insertnumber counter1,					1,'999'

	insertnumber tempResult,		  		0,'99.999'
	insertnumber NumberWithPicture,   1234567,'###.9999-' 
	insertnumber NumberWithoutPicture,		0

    ;   For Synonyms
	insertnumber n_CommentPosition,	 		0,'999'
	insertnumber n_NoOfSpaces,		 		0,'999'
	
;	For Version 1.18
	insertnumber n_V118_integer1,			0,'9999'
	insertnumber n_V118_integer2,			0,'9999'
	insertnumber n_V118_integer3,			0,'9999'
	insertnumber n_V118_integer4,			0,'9999'	

	insertnumber n_V118_number1,		123.4,'999.9'
	insertnumber n_V118_number2,		12.34,'99.99'
	insertnumber n_V118_number3,		1.234,'9.999'
	insertnumber n_V118_number4,		.1234,'.9999'
	insertnumber n_V118_number5,		.1234,'#.999999'	
	
%include 'include/END.MATRIX'

;=======================================================================
;		PROGRAM INSTRUCTIONS
;		Mainline  
;=======================================================================
%include 'include/BEGIN.INSTRUCTIONS'
;	Using Sub Routines is the common programming practice of breaking up 
;	programs  into  smaller  and  more  manageable  tasks.  To  invoke a
;	SubRoutine you use the 'keyword' $Call followed by the procedure name.
;	SubRoutines may invoke other SubRoutines.
	
	$Call Routine0A

	$Call Routine1A
	$Call Routine1B
	$Call Routine1C

	$Call Routine2A
	$Call Routine2B
	$Call Routine2C

	$Call Routine3A
	$Call Routine3B
	$Call Routine3C

	$Call Routine4A
	$Call Routine4B
	$Call Routine5A
	$Call Routine6A
	$Call Routine10A

%include 'include/END.INSTRUCTIONS'
%include 'include/END.PROGRAM'      

;=======================================================================
;	Routine to demonstrate its function
;=======================================================================	
BEGIN.SUB Routine0A
;	Using SubRoutines is the common  programming practice of breaking up 
;	programs into smaller and more manageable tasks. They start with the
;	'keyword' BEGIN.SUB followed by a  unique name that you choose. 
;	They  end  with the  'keyword' END.SUB  followed by  the same unique  
;	name you have chosen. To invoke a SubRoutine you use the 'keyword'
;	$Call followed by the SubRoutines name.	
;	SubRoutines may invoke other SubRoutines.
;
;	NOTE:- All keywords in languageONE are case INsensitive.
;		That is:- BEGIN.SUB, begin.sub, BeGiN.Sub are all equivalent.
;
;	WORKING WITH SIGNED INTEGERS
;	Some Basics:-
;		There are certains things that are inherent in writing computer
;		programs. They are  1) Setting the value of a number [Note:Integer]
;							2) Adding to a number [Note:Integer]
;							3) Subtracting from a number [Note:Integer]
;							4) Multiplying a number [Note:Integer]
;							5) Dividing a number [Note:Integer]
;	There are 5 corresponding commands in languageONE to accomplish
;	these common tasks. They are:-
;		integers.eq  (MatrixNumber[Note:Integer],81) 	Set the value of MatrixNumber[Note:Integer] to 81
;		integers.add (MatrixNumber[Note:Integer],2)		Add 2 to MatrixNumber[Note:Integer]
;		integers.sub (MatrixNumber[Note:Integer],5)		Subtract 5 from MatrixNumber[Note:Integer] 
;		integers.mul (MatrixNumber[Note:Integer],8)		Multiply a MatrixNumber[Note:Integer] by 8
;		integers.div (MatrixNumber[Note:Integer],4)		Divide a MatrixNumber[Note:Integer] by 2
;
;	It must noted that languageONE does no error checking for simple integer manipulation 
;	When the integer crosses the 9,223,372,036,854,775,807 boundary it will become negative
;	When the integer crosses the 9,223,372,036,854,775,808- boundary it will become positive
;	Note also that the simple division will not return a remainder value. Only a quotient is returned

	display (c_ClearScreen,c_DefaultBG, LF)

	display c_CyanFG,('Integer functions'),LF,c_GreenFG
	integers.eq (I,80)
	display ('  Set I to 80;        = ',I,LF)
	integers.add(I,80)
	display ('  Add 80 to I;        = ',I,LF)
	integers.sub(I,40)
	display ('  Subtract 40 from I; = ',I,LF)
	integers.mul (I,4)
	display ('  Multiply I by 4;    = ',I,LF)
	integers.div(I,10)
	display ('  Divide I by 10;     = ',I,LF)		
	$Call GetUserInput

;	Synonyms introduced in V1.17
	display c_CyanFG,('Synonyms introduced in V1.17'),LF,c_GreenFG
	@.eq (I,80)
	display ('  Set I to 80;        = ',I,LF)
	@.add(I,80)
	display ('  Add 80 to I;        = ',I,LF)
	@.sub(I,40)
	display ('  Subtract 40 from I; = ',I,LF)
	@.mul (I,4)
	display ('  Multiply I by 4;    = ',I,LF)
	@.div(I,10)
	display ('  Divide I by 10;     = ',I,LF)		
	$Call GetUserInput
	
;	'.CALC' introduced in V1.18
;	This allow intergers to be 'calculated in a compound statement
	display c_CyanFG,(".CALC introduced in V1.18"),LF,c_GreenFG
	integers.eq   I,10
	integers.eq   J,20
	integers.eq   K,30
	integers.calc L = I + J / K * I
	display '  Calc Integers) L=',L,LF

	@.eq I,30
	@.eq J,20
	@.eq K,10
	@.calc L = I + J / K * I
	display '  Calc Synonyms) L=',L,LF
	$Call GetUserInput
	
;	Additionally in V1.18 the translator is able to infer the .CALC statemnt
;	and as such may be omitted
	display c_CyanFG,(".CALC can be inferred - introduced in V1.18"),LF,c_GreenFG 
	L = I + J + K / K * J - 1
	display '  Calc Infered) - L=',L,LF		
	$Call GetUserInput		

;	Additionally in V1.21 the translator is able to perform integer pecedence
	display c_CyanFG,("Integer precedence - introduced in V1.18"),LF,c_GreenFG 
	display '  Precedence : [ I + J + K / I * J - 1] ', [I + J + [K / I] * [J - 1]],LF		
	$Call GetUserInput		
			
END.SUB Routine0A

;=======================================================================
;	Routine to demonstrate the display function
;=======================================================================			
BEGIN.SUB Routine1A
;	display is  a  'keyword'  used to  display characters  on a terminal
;	WITHOUT moving to  the next line.  It can be used  with literals and
;	with dictionary words/matrix numbers. display can display more  than
;	one word at a time. To do so, code each  word seperated  by a comma.
;	display will  also  allow you to  clear the screen,  add colours and
;	set/reset attributes by  preceeding your  text  with  the  'keyword'
;	that  describes the required result 
;
;	V1.14a introduces graphics characters...
;
;	CLEAR SCREEN
;		c_ClearScreen
;
;	COLOURS
;	  FOREGROUNDSWF150171
;		c_defaultFG		c_DarkGreyFG
;		c_RedFG			c_LightRedFG
;		c_GreenFG		c_LightGreenFG
;		c_YellowFG		c_LightLightYellowFG								
;		c_BlueFG		c_LightBlueFG	
;		c_MagentaFG		c_LightMagentaFG
;		c_CyanFG		c_LightCtyanFG
;		c_LightGreyFG
;	  BACKGROUNDS
;		c_defaultBG		c_DarkGreyBG
;		c_RedBG			c_LightRedBG
;		c_GreenBG		c_LightGreenBG
;		c_YellowBG		c_LightYellowBG								
;		c_BlueBG		c_LightBlueBG	
;		c_MagentaBG		c_LightMagentaBG
;		c_CyanBG		c_LightCtyanBG
;		c_LightGreyBG
;
;	  ATTRIBUTES
;		c_Bold			c_ResetBold
;		c_Dim			c_ResetDim
;		c_Underlined	c_ResetUnderlined
;		c_Blink			c_ResetBlink
;		c_Reverse		c_ResetReverse
;		c_Hidden		c_ResetHidden
;						c_ResetAll
;
;	  GRAPHICS CHARACTERS
;		c_BottomRight
;		c_TopRight
;		c_TopLeft
;		c_BottomLeft
;		c_Cross
;		c_Line
;		c_LeftMiddle
;		c_RightMiddle
;		c_BottomMiddle
;		c_TopMiddle	
;		c_Bar
;
;	If you prefer a more  succinct  way of writing  these  you may alter
;   the  OPEN.DICTIONARY file and  rename colour  combinations or create
;	your own escape values by inserting them into the dictionary.							
;  
;	NOTE:- By adding the built in  (L)ine(F)eed word you are effectively 
;		   replicating the display.line keyword (refer next Routine)
;		   The following are functionally equivalent
;		   	display 'Hello World',LF
;		   	display.line 'Hello World'


	display (c_ClearScreen,c_DefaultBG, LF)
	display (c_RedFG,c_Underlined,'01A] DEMONSTRATING the display routine',c_ResetUnderlined,LF)
	
	display (c_GreenFG)			
	display ('The quick ','The quick brown ','The quick brown fox ', LF)
	display (word1,' ',word2,spaces(1),'Literal after 2 Dictionary words')
	display (LF)

	$Call GetUserInput

;	Note in this Routine the use of a space, as a literal ' ' or as a 
;	command spaces(01). The spaces() command can be used with a 
;	matrix number (a variable) or a literal as is coded here.
;	The value denotes the number of spaces to be used.
	
END.SUB Routine1A

;=======================================================================
;	Routine to demonstrate the display.line function
;=======================================================================	
BEGIN.SUB Routine1B
;	display.line is a 'keyword' used to display characters on a	terminal
;	AND THEN  MOVE TO THE NEXT LINE.  It can be used in  the same way as 
;	the display statement. Note though If you display.line more  than one
;	item (seperated by comma's) then each  item will display on seperate
;	lines

	display (c_RedFG,c_Underlined,'1B] DEMONSTRATING the display.line routines',c_ResetUnderlined,LF)
	
	display 	 (c_GreenFG)
	display.Line ('The quick brown fox jumps over the lazy dog')
	display.Line ('The','The quick','The quick brown','The quick brown fox')
	display.Line (word1, word2, 'Literal after 2 Dictionary words')	

	$Call GetUserInput
	
END.SUB Routine1B

;=======================================================================
;	Routine to demonstrate the common functions
;=======================================================================
BEGIN.SUB Routine1C
;	Command line parameters  are made  available to the  program and are
;	stored  in the  system  word  'w_CommandLine'  while  the acceptLINE
;	routine  will  accept input  from the  terminal and  store it in the
;	provided word

	display (c_RedFG,c_Underlined,'1C] DEMONSTRATING the Commandline/acceptLine routines',c_ResetUnderlined,LF)

	display 	(c_GreenFG)
	display.line ('If you start the program with some text as a parameter')
	display.line 'it will be echoed back to you'
	display (c_GreenFG, w_CommandLine, c_LightYellowFG,LF)
	
	display 	(c_GreenFG)
	display.line ('acceptLine is the "keyword" used to support user input')
	display 	('What is your full name: ',c_MagentaFG)
	acceptLine  (inputLine)
	display (c_GreenFG,'Hello ',inputLine,LF)
	$Call GetUserInput

	display 	(c_GreenFG)
	display 	('Input into a number with a picture: ',c_MagentaFG)
	acceptLine  (NumberWithPicture)
	display (c_GreenFG,'Your no is ',NumberWithPicture,LF)

	display 	(c_GreenFG)
	display 	('Input into a number without a picture: ',c_MagentaFG)
	acceptLine  (NumberWithoutPicture)
	display (c_GreenFG,'Your no is ',NumberWithoutPicture,LF)
	
	$Call GetUserInput

END.SUB Routine1C

;=======================================================================
;		Routine to demonstrate the way words can be dissected
;=======================================================================	
BEGIN.SUB Routine2A
;	Literals and Dictionary words can be  'dissected' so that only parts
;	of words are selected. This is done by giving a Start Position and a
;	count of the  No  Of Characters required. When using this method the
;	word  and its associated requirements must  be surrounded by opening
;	and closing braces. That is:- '{' and '}'. 
;	For example:-
;		display	'The quick brown fox' 
;			is saying display this from beginning to end
;		display {'The quick brown fox',5}
;			is saying display this from character 5 to the end
;		display {'The quick brown fox',5,11} 
;			is saying display 11 characters starting from character 5
;		display {Fox,5,11} 
;		This applies to Dictionary words as well as literals
;		display {'The quick brown fox',Start,NoOfCharacters} 


	display (c_RedFG,c_Underlined,'02A] DEMONSTRATING the way words can be dissected',c_ResetUnderlined,LF)

	display 	(c_GreenFG)
	display.line ('The quick brown fox jumps over the lazy dog')
	display.line ({'The quick brown fox jumps over the lazy dog',5}) 
	display.line ({'The quick brown fox jumps over the lazy dog',5,11}) 
	
	display.line (Fox)
	display.line ({Fox,5})
	display.line ({Fox,5,11}) 
	display.line ({'The quick brown fox jumps over the lazy dog',Start}) 
	display.line ({'The quick brown fox jumps over the lazy dog',Start,NoOfCharacters})

	$Call GetUserInput
				
END.SUB Routine2A

;=======================================================================
;		Routine to demonstrate the way numbers can be displayed
;=======================================================================	
BEGIN.SUB Routine2B
;	numbers can  also be displayed.  They may  be a literal  or a number
;	from  the  Matrix.   A  literal  will  have  a  default  picture  of
;	'#,###,###,###,###,###,###-'  A picture can be coded  following  the
;	literal (all in braces) to inform display as  to how  to alternately
;	format the number. When displaying a number from the matrix a picture
;	may also be supplied. This will override the default picture. 


	display (c_RedFG,c_Underlined,'2B] (display.line) DEMONSTRATING number displays',c_ResetUnderlined,LF
	
	display	(c_GreenFG,'Integer literal alone ',-1234567, LF)
	display ('Integer literal with picture override ', {-1234567, '999-'},LF)
	display ('Matrix integer WITHOUT picture override ',NumberWithPicture,LF)
	display ('Matrix integer WITH picture override [999.999] ',{NumberWithPicture,'999.999'},LF)

	display.line
	display ('Rational literal must be followed by a picture ',{1234567,'99.9999'},LF)

;	Introduced in V1.18
;	where as a fixed point number used as a literal following the begin.instructions directive
;	needed a picture, The translator will now provide that picture such that you may code only
;	the fixed point number. 
	display.line
	display.line 'V1.18 - Translator provides the picture when coding a fixed point number'
	display ('Fixed Point number, tanslator supplying the picture  ',-123.4567,LF)	

	$Call GetUserInput

END.SUB Routine2B

;=======================================================================
;		DEMONSTRATING a simple program with terminal usage
;=======================================================================
BEGIN.SUB Routine2C
;	Text may be  displayed or  accepted from  dIfferent positions on the
;	screen.  This can be  done by  setting the  row and  column position
;	with the CURSOR macro
;	First prepate the screen by displaying the c_ClearScreen field

	display (c_ClearScreen)

	cursor  (02,02)
	display (c_RedFG,c_Underlined,'2C] Routine TO DEMONSTRATE cursor CONTROL',c_ResetUnderlined)
	
	cursor  (04,05)
	display (c_DefaultFG,'Prompt No 1')
	cursor  (05,05)
	display ('Prompt No 2')
	cursor  (06,05)
	display ('Prompt No 3')

	cursor  (04,18)
	display (c_CyanFG)
	acceptLine (inputLine)
	
	cursor  (05,18)
	display (c_CyanFG)
	acceptLine (inputLine)

	cursor  (06,18)
	display (c_CyanFG)
	acceptLine (inputLine)
	
END.SUB Routine2C

;=======================================================================
;		Routine to demonstrate the way the words package works
;=======================================================================	
BEGIN.SUB Routine3A	
;	The  words  package  contains  the  routines  that are  available to 
;	manipulate  words from  the dictionary  (and literals).  It includes
;	support for output from the matrix or numeric literals.
;	The format for words is the keyword 'words.' followed by the required
;	operation, the source and the destination (optional)
;	ie. words.copy 'This is a literal', outputLine
;	The following operations are supported.
;		words.copy 
;		words.pad
;		words.uppercase
;		words.lowercase
;		words.insert
;		words.find
;		words.replace
;		words.environment
;	In some cases the destination is optional. If not supplied the source
;	is used as the destination. ie 'words.uppercase, word1'

	display		(c_RedFG,c_Underlined,'3A] Routine TO DEMONSTRATE THE WORDS PACKAGE',c_ResetUnderlined,LF)
	@.eq		(I,5)
	
	display 	(spaces(I),c_RedFG,'SIMPLE COPY - WORD TO WORD',LF)
	$.copy		(Fox,outputLine)
	display		(spaces(I),c_LightYellowFG,outputLine,LF)
	$Call 		 GetUserInput
	
	display 	(spaces(I),c_RedFG,'SIMPLE COPY - LITERAL TO WORD',LF)
	$.copy		('THIS IS A LITERAL', outputLine)
	display 	(spaces(I),c_LightYellowFG,outputLine,LF)
	$Call 		 GetUserInput
	
	display 	(spaces(I),c_RedFG,'SIMPLE PAD - LITERAL TO WORD',LF)
	$.pad		('literal with padding', outputLine)
	display 	(spaces(I),c_LightYellowFG,outputLine, LF)
	$Call 		 GetUserInput
	
	display 	(spaces(I),c_RedFG,'CONVERT TO UPPERCASE',LF)
	$.uppercase (outputLine)
	display 	(spaces(I),c_LightYellowFG,outputLine,LF)
	$Call 		 GetUserInput
	
	display 	(spaces(I),c_RedFG,'AND BACK TO LOWERCASE',LF)
	$.lowercase ('CONVERT BACK TO LOWERCASE', outputLine)
	display 	(spaces(I),c_LightYellowFG,outputLine,LF)
	$Call 		 GetUserInput
	
	display 	(spaces(I),c_RedFG,'DEMONSTRATE COPY OPERATION - {WORD1,10}, WORD2',LF)
	$Call 		 Routine3A_A
	$.copy 		({word1,10}, word2)
	display 	(spaces(I),c_LightYellowFG,word2,LF)
	$Call 		 GetUserInput
		
	display 	(spaces(I),c_RedFG,'DEMONSTRATE COPY OPERATION - {WORD1,3,5}, WORD2',LF)
	$.copy		('12345678901234567890123456',word2)
	$Call 		 Routine3A_A
	$.copy		({word1,3,5},word2)
	display 	(spaces(I),c_LightYellowFG,word2, LF)
	$Call 		 GetUserInput

	display 	(spaces(I),c_RedFG,'DEMONSTRATE COPY OPERATION - {WORD1,3,5}, {WORD2,11}',LF)
	$.copy		('12345678901234567890123456', word2)
	$Call 		 Routine3A_A
	$.copy		({word1,3,5}, {word2,11})
	display 	(spaces(I),c_LightYellowFG,word2,LF)
	$Call 		 GetUserInput

	display 	(spaces(I),c_RedFG,'DEMONSTRATE INSERT OPERATION - {WORD1,1,12}, {WORD2,11}',LF)
	$.copy		('12345678901234567890123456',word2)
	$Call 		 Routine3A_A
	$.insert	({word1,1,12},{word2,11})
	display		(spaces(I),c_LightYellowFG,word2,LF)
	$Call 		 GetUserInput
	
	display		(spaces(I),c_RedFG,'DEMONSTRATE FIND OPERATION - rst in word1',LF)
	$Call 		 Routine3A_A
	$.find		({'rst',counter1},word1)
	display		(spaces(5), '"rst" starts @ character ', counter1,LF)
	$Call 		 GetUserInput
	
	display 	(spaces(I),c_RedFG,'DEMONSTRATE FIND OPERATION - rst in word1 - starting at 19',LF)
	$Call 		 Routine3A_A
	$.find 		({'rst',counter1},{word1,19})
	display 	(spaces(I), '"rst" not found ',counter1,LF)
	$Call 		 GetUserInput
	
	display 	(spaces(I),c_RedFG,'DEMONSTRATE REPLACE OPERATION - replace "12" with "~~" ',LF)
	$.pad 		('123412341234', word2)
	$Call 		 Routine3A_A
	display 	(spaces(I), word2,LF)
	$.replace	({'12','~~'},word2)
	display 	(spaces(I),word2,LF)
	$Call 		 GetUserInput

	display 	(spaces(I),c_RedFG,'DEMONSTRATE REPLACE OPERATION - replace {"12","~~",2,1}')
	display 	('= DUMB but still do-able',LF)
	$.copy 		('12345678901234567890123456',word2)
	$Call 		 Routine3A_A
	display 	(spaces(I),word2,LF)
	$.replace	({'12','~~',2,1},word2)
	display 	(spaces(I),word2,LF)
	$Call 		 GetUserInput

;	NOTE:- An alternate syntax exists whereby you may combine operations
;	ie. words uppercase+pad, 'This is a literal', outputLine
;	By coding words and combining operations with = '+' sign, followed 
;	by a comma the words package will perform both functions. 
;	Code the operation preceeded by the '$' sign. ie.
;		words $copy, Src, Dest 
;		words $pad, Src, Dest
;		words $uppercase, Src
;		words $lowercase, Dest
;		words $insert, '123', {Dest,5}
;		words $find, '123', Src
;		words $replace, {'123','456'}, Dest

	display 	(spaces(I),c_RedFG,'DEMONSTRATE COMBINING OPERATIONS - Uppercase+Pad',LF )
	$.copy 		('123456789012345678901234567890',word2)
	display 	(c_GreenFG,spaces(I),word2,LF)
	WORDS		 $uppercase+$pad, ('uppercase and pad',word2)
	display 	(c_LightYellowFG,spaces(I), word2,LF)
	$Call 		GetUserInput

;	Additionally in V1.18 the translator is able to add the WORDS keyword and 
;	to rearrange the statement to suit a more traditional style of programming.
;	ie:-
	display (spaces(I),c_RedFG,'DEMONSTRATE INFERED MACROS',LF )
	$Call Routine3A_A
	
	word2 = word1
	
	display (c_GreenFG,spaces(I),'word2 = word1'),LF
	display c_LightYellowFG,spaces(I),word1,LF	
	
	{word2,1} = {word1,26,1}
	
	display (c_GreenFG,spaces(I),'{word2,1} = {word1,26,1}'),LF
	display c_LightYellowFG,spaces(I),word2,LF
	$Call GetUserInput
		
END.SUB Routine3A

;---$Called from Routine3A
BEGIN.SUB Routine3A_A
;	Demonstrates how $Calling a Routine from a Routine can occur
	
;	word1 'abcdefghijklmnopqrstuvwxyz'        
;	word2 '12345678901234567890123456'

	display (c_GreenFG)
	display (spaces(5),word1,'(Word1)',LF)
	display (spaces(5),word2,'(Word2)',LF)
	display (c_LightYellowFG

END.SUB Routine3A_A

;=======================================================================
;		DEMONSTRATING the way the words package works (#)
;=======================================================================	
BEGIN.SUB Routine3B	
;	The  words packages works with numbers by first converting them into
;	alphanumeric  fields  (alphabetic fields that  contain numbers)  and
;	then displaying them.  A default picture is used for  literals while
;	Matrix numbers use their own picture. Pictures may be over-ridden on
;	both literals and matrix numbers. 

	display c_RedFG,c_Underlined,'3B] Routine TO DEMONSTRATE THE WORDS PACKAGE (#)',c_ResetUnderlined,LF
	display spaces(5),'DEMONSTRATE Numeric copy ',LF

;	Default picture for a integer literal is 26 characters and so this move would fail
;	as he numericBuffer is only 16 characters long.
;		$.pad 12345, numericBuffer
;		display spaces(5),c_LightYellowFG,numericBuffer,LF

;	word2 is large enough for the move
	$.pad 12345, word2
	display spaces(5),c_LightYellowFG,word2,LF

;	OR use a picture over-ride
	$.pad {12345,'####9'},numericBuffer
	display spaces(5),c_LightYellowFG,numericBuffer,LF
	$Call GetUserInput
	
	display spaces(5),c_RedFG,'DEMONSTRATE Matrix copy',LF
	$.pad NumberWithPicture, numericBuffer
	display spaces(5),c_LightYellowFG,numericBuffer,LF
	$Call GetUserInput
	
	display (spaces(5),c_RedFG,'DEMONSTRATE Matrix copy with picture',LF)
	$.copy (word1,outputLine)
	$.copy ({NumberWithPicture,'##9.99'},{outputLine, 30})
	display (spaces(5),c_LightYellowFG,{outputLine,1,40},LF)
	$Call GetUserInput

;	Introduced in V1.18
;	where as a fixed point number used as a literal following the begin.instructions directive
;	needed a picture, The translator will now provide that picture such that you may code only
;	the fixed point number. 

	display (spaces(5),c_RedFG,'DEMONSTRATE Literal copy without picture',LF)
	$.copy (word1,outputLine)
	$.copy (123.456,{outputLine, 30})
	display (spaces(5),c_LightYellowFG,{outputLine,1,40},LF)
	$Call GetUserInput

END.SUB Routine3B

;=======================================================================
;		DEMONSTRATING the way the WORDS package works (Environement)
;=======================================================================	
BEGIN.SUB Routine3C	
;	The words package is also used to handle environment variables.
;	Pass the  Environment Variable  name to  the package  and the  value  
;	associated  with  that name  will be  returned  in  the  destination
;	field.

	display (c_ClearScreen)
	cursor  (02,02)
	display (c_RedFG,c_Underlined,'3C] Routine TO DEMONSTRATE the WORDS package - Environment variables',c_ResetUnderlined)
	cursor  (03,02)
	display ('Type printenv on another terminal to list environment variables')

	cursor  (04,02)
	display (c_CyanFG,'Please enter an Environment Variable name: ')
	display (c_LightYellowFG)
	cursor  (04,45)
	acceptLine (inputLine)
	$.uppercase (inputLine)

	$.pad (spaces(1),outputLine)         
	$.environment (inputLine,outputLine)

	cursor  (06,02)
	display (c_CyanFG,'The value associated with this name is=',c_GreenFG,outputLine,LF)
	$Call GetUserInput	

END.SUB Routine3C

;=======================================================================
;		DEMONSTRATING the way the If/else/END constructs
;=======================================================================	
BEGIN.SUB Routine4A
;	'languageONE'  contains the  functionality to  implement  decisions.
;	It is performed via the If/else/ENDIf construct
;   The  'If'  keyword is followed by  3  parameters,  then a  series of 
;	statements to be executed, and terminates with an 'ENDIf'  keyword.
;	The  'else'  keyword may be used to  denote an  alternate  series of
;	statements in the event that the 'If' condition is not met.
;
;	There are 6 decisions that can be made. They are:
;		Equals				equ 00000001b (1)
;		isNOTEqualTo		equ 00000010b (2)
;		isLessThan			equ 00000100b (4)
;		isNOTLessThan 		equ 00001000b (8)
;		isGreaterThan		equ 00010000b (16)													
;		isNOTGreaterThan	equ	00100000b (32)
;
;	If you prefer a more  succinct  way of writing  these you may define
;	your own names as long as there value is that of the above. ie:
;		EQ	 equ 1
;		N_EQ equ 2
;		LT	 equ 4
;		N_LT equ 8
;		GT	 equ 16
;		N_GT equ 32
;	you may then write your decision statements as follows:-
;	If {'Name',EQ,w_1stName}


;	Examples
	display (c_RedFG,c_Underlined,'04A] Routine TO DEMONSTRATE THE Decisions PACKAGE',c_ResetUnderlined,LF)
	display (c_RedFG,spaces(5),'DEMONSTRATE Word Decisions',LF)

	If ('abcdef',isLessThan,'ABCDEF')
		display (spaces(5),c_RedFG,'NOT WORK-abcdef,isLessThan,ABCDEF',LF)
	else
		display (spaces(5),c_GreenFG,'abcdef,isNOTLessThan,ABCDEF',LF)
	end.if
	
	If ({'abcdef'},isGreaterThan,{'ABCDEF'})
		display (spaces(5),c_GreenFG,'{abcdef},isGreaterThan,{ABCDEF}',LF)
	else
		display (spaces(5),c_RedFG,'NOT WORK-{abcdef},isNOTGreaterThan,{ABCDEF}',LF)
	end.if

	If ({'abcdef',3},Equals,{'ABcdef',3})
		display (spaces(5),c_GreenFG,'{abcdef,3},Equals,{ABcdef,3}',LF)
	end.if
	
	If ({'abcdef',3,2},EQ,{'ABcdEF',2})
		display (spaces(5),c_GreenFG,'{abcdef,3,2},Equals,{ABcdEF,2}',LF)
	end.if
	
	If ({'abcdef',2,2},EQ,{'ABcdEF',5})
		display (spaces(5),c_GreenFG,'{abcdef,2,2},Equals,{ABcdEF,5}',LF)
	else
		display (spaces(5),c_RedFG,'{abcdef,2,2},Does Not Equal,{ABcdEF,5}',LF)
	end.if
	
	$Call GetUserInput	


	display (spaces(5),c_RedFG,'DEMONSTRATE Integer Decisions -1',LF)
	If ({1,'9'},N_EQ,{1,'9'})
		display (c_RedFG,spaces(5),'1,isNOTEqualTo,1',LF)
	else	
		If (1,GT,1)
			display (c_RedFG,spaces(5),'1,isGreaterThan,1',LF)
		else
			If (1,LT,1)
				display (c_RedFG,spaces(5),'1,isLessThan,1',LF)
			else
				If (1,N_LT,1)
					display (c_GreenFG,spaces(5),'1,isNOTLessThan,1',LF)
					If (1,N_GT,1)
						display (c_GreenFG,spaces(5),'1,isNOTGreaterThan,1',LF)
					end.if
				end.if
			end.if
		end.if
	end.if
	$Call GetUserInput


	display (spaces(5),c_RedFG,'DEMONSTRATE Integer Decisions -2',LF)
	If (1,EQ,1)
		display (c_GreenFG,spaces(5),'1 Equals 1',LF)
		If (1,N_LT,1)
			display (c_GreenFG,spaces(5),'1 isNOTLessThan 1',LF)
			If (1,N_GT,1)
				display (c_GreenFG,spaces(5),'1 isNOTGreaterThan 1',LF)
				If (1,N_EQ,1)
				else
					display (c_GreenFG,spaces(5),'1 isEqualTo 1',LF)
					If (1,GT,1)
					else
						display (c_GreenFG,spaces(5),'1 isNOTGreaterThan 1',LF)
						If (1,LT,1)
						else
							display (c_GreenFG,spaces(5),'1 isNOTLessThan 1',LF)					
						end.if
					end.if
				end.if
			end.if
		end.if
	end.if
	$Call GetUserInput	


	display (spaces(5),c_RedFG,'DEMONSTRATE Fixed PointNumeric Decisions -3',LF)
	If ({1,'9.9'},N_EQ,{1,'9'})
		display (c_GreenFG,spaces(5),"{1,'9.9'},N_EQ,{1,'9'}",LF)
	end.if
	If ({10,'9.9'},EQ,{1,'9'})
		display (c_GreenFG,spaces(5),"{10,'9.9'},EQ,{1,'9'}",LF)
	end.if
	If ({1230000,'999.9999-'},EQ,NumberWithPicture)
		display (c_GreenFG,spaces(5),"{1230000,'999.9999-'},EQ,NumberWithPicture",LF)
	end.if
	If ({123000,'999.999'},EQ,NumberWithPicture)
		display (c_GreenFG,spaces(5),"{123000,'999.999-'},EQ,NumberWithPicture",LF)
	end.if

	If ({1234567,'999.9999-'},EQ,NumberWithPicture)
		display (c_GreenFG,spaces(5),"{1234567,'999.9999-'},EQ,NumberWithPicture",LF)
	end.if

	If ({123000,'999.9999-'},N_EQ,NumberWithPicture)
		display (c_GreenFG,spaces(5),"{123000,'999.9999-'},N_EQ,NumberWithPicture",LF)
	end.if
	$Call GetUserInput			

;	Introduced in V1.18
;	where as a fixed point number used as a literal following the begin.instructions directive
;	needed a picture, The translator will now provide that picture such that you may code only
;	the fixed point number. 
	if 123.456 = 123.456
		display (c_GreenFG,spaces(5),"{123.456 = 123.456},Equals,Literals Without Picture",LF)
	else
		display (c_RedFG,spaces(5),"This should not fail",LF)
	end.if
	$Call GetUserInput
	
END.SUB Routine4A

;=======================================================================
;		DEMONSTRATING the way @OR/@AND works
;=======================================================================	
BEGIN.SUB Routine4B
;	COMPOUND IF staements can be formed with the .IF .OR .AND and the .END
;	keywords.
;	In effect the .IF .OR and .AND keywords set a decision flag to TRUE/FALSE
;	which is then interpreted by th .END keyword.
;	When an .OR follows the .IF then the  comparison is made and the flag
;	is  reset accordingly.  The same applies with  .AND in that  it will 
;	reset the comparison flag.
;
;	In effect an AND can be coded as
;	If 1,Equals,1
;		If 2,Equals,2
;			.
;	and an OR can be coded as
;	If 1,Equals,1
;		@.eq(I,1)
;	ENDIf
;	If 2,Equals,2
;		@.eq(I,1)
;	ENDIf
;
;	Complex conditions such as follows will be addressed in a later	
;	version:- It should be noted that on scanning previously written
;	applications the need for complex decisions is minimal
;
;	If (A=A AND B=B) OR ((C=C OR D=D) AND E=E) AND ((F=F OR G+G)) 
;	etc
;

	display (c_RedFG,c_Underlined,'04B] Routine TO DEMONSTRATE THE Decisions PACKAGE',c_ResetUnderlined,LF)
	display (spaces(5),'DEMONSTRATE AND, OR',LF)
	
	.If (0,EQ,1)
    .or (1,EQ,1)
   .end
		display (spaces(5),c_GreenFG, '0=1 OR 1=1 is evaluated as TRUE',LF)
	else
		display (spaces(5),c_GreenFG, '0=1 OR 1=1 is evaluated as FALSE',LF)
	end.if
	
	.If (0,EQ,1)
   .and (1,EQ,1)
   .end
		display (spaces(5),'0=1 AND 1=1 is evaluated as TRUE',LF)
	else
		display (spaces(5), '0=1 AND 1=1 is evaluated as FALSE',LF)
	end.if
	
	.If (0,EQ,{1,'9'})
    .or (1,EQ,{20,'9.9'})
    .or (3,EQ,{300,'9.99'})
   .end
		display (spaces(5), '0=1 OR 1=2 OR 3=3 is evaluated as TRUE',LF) 
	else
		display (spaces(5), '0=1 OR 1=2 OR 3=3  is evaluated as FALSE',LF)
	end.if
	
	.If (1,EQ,1)
   .and (2,EQ,{20,'9.9'})
   .and (3,EQ,{300,'9.99'})
   .end
		display (spaces(5), '1=1 AND 2=2 AND 3=3 is evaluated as TRUE',LF)
	else
		display (spaces(5), '1=1 AND 2=2 AND 3=3  is evaluated as FALSE',LF)
	end.if

   .If (0,Equals,1)
   .or (2,Equals,2)
  .and (3,Equals,3.00)
  .end
		display (spaces(5),'0=1 OR 2=2 AND 3=3 is evaluated as TRUE',LF)
	else
		display (spaces(5), '0=1 OR 2=2 AND 3=3  is evaluated as FALSE',LF)
	end.if
 	
	$Call GetUserInput
	
END.SUB Routine4B
	
;=======================================================================
;		DEMONSTRATING the way the LOOPS work
;=======================================================================	
BEGIN.SUB Routine5A	
;	'languageONE'  contains the  functionality to  implement  looping, a
;	common  programming function  where a command or  number of commands
;	are repeated a number of times.
;
;	There are 3 types of loop designated with the following keywords:- 
;		repeat <name>	(Named Loop) 		exit.repeat /END.repeat
;		repeat.IF		(Conditional Loop) 				/END.repeat
;		repeat.FOR		(Loop Counter)					/END.repeat
;
;		As  with the  IF statement loops must  be blocked and this is
;		done withe END.repeat keyword.
;
;		NAMED Loops  must/can have  an exit
;			This is facilitated with the keyword exit.repeat
;
;		CONDITIONAL and COUNTER loops syntactically describe their own terminating
;		condion
;
;		All three versions of the repeat keyword have an additional way of
;		termination. They all evaluate the 'exitRepeat' flag at the top of the
;		loop and will terminate if it is set to true. Care should be taken when
;		setting the flag as any statements following will still be processed.
;		It is simplest to code an IF/ELSE statement immediatelly following the 
;		repeat kwyword. 
;
;	The  condition  that  must  be  met  for  the  loop to continue in a 
;	Conditional Loop is coded in the same way as an If would be coded.
;
;	Consider the following examples.

	display c_ClearScreen
	display c_RedFG,c_Underlined,'05A] Routine TO DEMONSTRATE LOOPING',c_ResetUnderlined,LF
		
;	LOOP 1 - Named Loop
	display 'LOOP 1 - Named Loop',LF
	I = 0
	repeat _01
		I = I + 1
		If (I > 5)
			exit.repeat _01
		else
			display (spaces(5),c_GreenFG,'Loop1 - display 5 times',LF)
		end.if
	end.repeat _01
	$Call GetUserInput

;	LOOP 2 - Conditional Loop
	display (c_RedFG,'LOOP 2 - Conditional Loop',LF)
	I = 5
	repeat.If (I,GT,0)
		display (spaces(5),c_GreenFG,'Loop2 - display 5 times',LF)
		I = I - 1
	end.repeat	
	$Call GetUserInput
	
;	LOOP 3 - Loops may be nested. That is Loops within Loops
	display.line
	display (spaces(5), 'Loop3 - Nested Loop',LF)
	
	I = 0
	repeat.If (I,LT,2)
		display (spaces(5),c_RedFG,outerWord,LF)
		I = I + 1		
		J = 0	
		repeat.If (J,LT,2)
			display (spaces(10),c_GreenFG,middleWord,LF)
			J = J + 1
			K = 0
			repeat.If (K,LT,2)	
				display (spaces(15),c_CyanFG,innerWord,LF)
				K = K + 1
			end.repeat
		end.repeat
	end.repeat
	$Call GetUserInput

;	LOOP 4 - exiting nested loops
	display.line
	display (spaces(5), c_RedFG,'Loop4 - Nested Loop with exit',LF)

	I = 0
	repeat.If (I,LT,10)
		If (I,GT,1)
			exitRepeat = c_TRUE
		else		   
			display (spaces(5),c_RedFG,outerWord,LF)
			I = I + 1		
			J = 0
			repeat.If (J,LT,20)
				If (J,GT,1)
				   exitRepeat = c_TRUE
				else
					display (spaces(10),c_GreenFG,middleWord,LF)
					J = J + 1			
					K = 0
					repeat.If (K,LT,30)
						If (K,GT,2)
							exitRepeat = c_TRUE
						else				
							display (spaces(15),c_CyanFG,innerWord,LF)
							K = K + 1
						end.if
					end.repeat
				end.if
			end.repeat
		end.if
	end.repeat
	$Call GetUserInput

;   Loops with counters are coded in the following manner.
;	repeat.FOR {IdentIfier}, Counter, Start Value, End Value, Step
;		The step value is optional and when omitted, 1 is assumed

;   Loop 5 - Loop with counter
	display (c_ClearScreen)
	display (spaces(5),c_RedFG,'Loop5 - Loops with counters',LF)
		
	repeat.for (I,1,5)
		display (spaces(5),c_GreenFG,I,' For I,1,5',LF)
	end.repeat 
	display.line
	
	repeat.for (I,5,1)
		display (spaces(5),c_YellowFG,I,' For I,5,1 (counting backwards)',LF)
	end.repeat 
	display.line
	
	repeat.for (I,1,10,2)
		display (spaces(5),c_CyanFG,I,' ForI,1,10,2 (with step)',LF)
	end.repeat
	display.line
	
	repeat.for (I,10,1,2)
		display (spaces(5),c_LightYellowFG,I,' For I,10,1,2 (backwards with step)',LF)
	end.repeat
	display.line
	
	repeat.for (I,1,10)
		If (I,GT,3)
			exitRepeat = c_TRUE
		else
			display (spaces(5),c_BlueFG,I,' For I,1,10 (with exit)',LF)
		end.if
	end.repeat
	display.line
	$Call GetUserInput

END.SUB Routine5A

;=======================================================================
;		DEMONSTRATING a more rigoreous rest
;=======================================================================
BEGIN.SUB Routine6A
;	The following demonstrates the combination of utilities presented in
;	languageONE v0.01A

	display c_ClearScreen
	display.at 01,01,'Combining languageONE utilities'
	
	@.eq(I,2)																								
	If (1,EQ,1)																			
		If (1,EQ,1)
			repeat.If (I,N_GT,5)					
				If (1,EQ,1)										
					If (1,EQ,1)									
						If (I,N_GT,3)						
							cursor (I,02)
							display ('First ',{I,'99'},' times',LF)
						else										
							exitRepeat = c_TRUE
						end.if																	
					end.if											
				end.if												
				@.add(I,1)
			end.repeat
		else												
			repeat.If (I,N_GT,10)
				If (1,EQ,1)										
					If (1,EQ,1)									
						If (I,LT,5)
							cursor (I,02)
							display ('Second ',{I,'99'},' times',LF)
						end.if										
					end.if											
				end.if												
				@.add(I,1)
			end.repeat
		end.if														
	else
		display.line ('Third - very bottom')
	end.if															
	$Call GetUserInput

;	And combining utilities with V1.18 additions
	display c_ClearScreen
	display 'Combining languageONE utilities (V1.18)',LF
	
	I = 2																								
	.If  1 = 1																			
  	.and 1.0 = 1.00
	.end
		repeat.If I,!>,5					
			.If 1 = 1										
		   .and 2.000 = 2
		   .end									
				If I !> 3.000						
					cursor (I,02)
					display ('First ',{I,'99'},' times',LF)
				else										
					exitRepeat = c_TRUE
				end.if																	
			end.if											
			I = I + 1
		end.repeat
	else												
		repeat.If I !> 10
		   .If 1 = 1										
		  .and 1 = 1.0000									
		  .and I < 5.000
		  .end
				cursor (I,02)
				display ('Second ',{I,'99'},' times',LF)
			end.if										
			I = I + 1
		end.repeat
	end.if															
	$Call GetUserInput
	
END.SUB Routine6A

;=======================================================================
;		DEMONSTRATING a simple program
;=======================================================================
BEGIN.SUB Routine10A
;	1] accept Text from the terminal
;	2] Capitalise it
;   3] Work backwards until the first NON space is found
;	4] display the no of characters entered
;	5] display the commandline backwards

;	User interaction
	display (c_ClearScreen)
	cursor  (02,02)
	display (c_RedFG,c_Underlined,'10A] Routine TO DEMONSTRATE A SIMPLE PROGRAM',c_ResetUnderlined)
	cursor  (03,02)
	display (c_CyanFG,'What is your full name: ')
	display (c_LightYellowFG)
	
	cursor  (03,26)
	acceptLine (inputLine)

;	Capitalise input
	$.uppercase (inputLine)
	
;	Find last character
	repeat.for (I,80,1)
		If ({inputLine,I,1},N_EQ,spaces(1))
			exitRepeat = c_TRUE
		end.if
	end.repeat
	
	cursor  (04,02)
	display ('Input Line is ', I, ' characters long', LF)

;	display input (backwards)
	cursor  (05,02)
	repeat.for (J,I,1)	
		display ({inputLine,J,1})
	end.repeat
	display.Line 
	
	$Call GetUserInput

;	The keyword TERMINATE was also added in V118. When used the program
;	will be stopped and the value specified will be returned to the shell
	TERMINATE 1
	
END.SUB Routine10A

;=======================================================================
;		Routines that are common (can be Called from anywhere)
;=======================================================================
BEGIN.SUB GetUserInput
	
	display (spaces(5),c_LightBlueFG,'Press <ENTER> to continue ')
	acceptline (char1)
	display c_WhiteFG,(LF)
	
END.SUB GetUserInput
